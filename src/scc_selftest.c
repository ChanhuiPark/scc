/* 
========================================
  scc_selftest.c
----------------------------------------
  Softcamp(c).
  2015.10.
========================================
*/

#define _CRT_SECURE_NO_DEPRECATE

#include <stdlib.h>
#include <string.h>
#ifdef _WIN32
#include <windows.h>
#endif

#include "scc_aria.h"
#include "scc_sha256.h"
#include "scc_sha512.h"
#include "scc_error.h"
#include "scc_hmac_sha.h"
#include "scc_cmvp.h"
#include "scc_drbg.h"
#include "scc_rsa.h"
#include "scc_kcdsa.h"
#include "scc_malloc.h"
#include "scc_pkey.h"
#include "scc_entropy.h"
#include "scc_util.h"

// 출처 : http://www.nis.go.kr/AF/1_7_3_5/view.do?seq=83&currentPage=1&selectBox=&searchKeyword=&fromDate=&toDate=

/**
 *
 *
 *
 */
typedef struct {
	int		cipherID;
	U8		plain[64];
	U32		plainLength;
	U8		cipher[64];
	U32		cipherLength;
	U8		key[48];
	U32		keyLength;
	int		modeID;
	U8		iv[16];
	U32		ivLength;
	int		paddingID;
} SC_CIPHER_TV;

static const
SC_CIPHER_TV	tv_cipher[] = {
	// ARIA
	{	SCC_CIPHER_ID_ARIA,
		{0x10,0x50,0x59,0x11,0xE4,0x2B,0x03,0xA2, 0xC0,0x21,0xBC,0xE4,0xF4,0xD6,0xE9,0xB5}, 16,
		{0x6A,0xBA,0xB3,0x88,0x71,0x86,0xDB,0xDF, 0xF1,0xBB,0x7F,0xE9,0xCC,0xA2,0xF8,0x75}, 16,
		{0x60,0x9A,0xC9,0xD7,0x4A,0xCB,0xA7,0x25, 0xEA,0x8F,0xB1,0x4C,0xE6,0x85,0x52,0x1A}, 16,
		SCC_CIPHER_MODE_CBC, 
		{0xA9,0xFB,0xF9,0x55,0xAB,0x18,0x76,0x97, 0xF2,0x5A,0xA8,0x5C,0xD9,0x44,0x55,0x5A}, 16,
		SCC_CIPHER_PADDING_NO
	},
	{	SCC_CIPHER_ID_ARIA,
		{0xC0,0x21,0xBC,0xE4,0xF4,0xD6,0xE9,0xB5, 0xB6,0x38,0x13,0x8E,0x66,0xB1,0x45,0x5B}, 16,
		{0x2E,0x2F,0xA3,0xB5,0xA5,0x06,0xB1,0xD1, 0xA5,0x3C,0x6B,0x08,0x60,0xFA,0xF8,0xDF}, 16,
		{0x60,0x9A,0xC9,0xD7,0x4A,0xCB,0xA7,0x25, 0xEA,0x8F,0xB1,0x4C,0xE6,0x85,0x52,0x1A, 
		 0xA9,0xFB,0xF9,0x55,0xAB,0x18,0x76,0x97}, 24,
		SCC_CIPHER_MODE_CBC, 
		{0xF2,0x5A,0xA8,0x5C,0xD9,0x44,0x55,0x5A, 0x10,0x50,0x59,0x11,0xE4,0x2B,0x03,0xA2}, 16,
		SCC_CIPHER_PADDING_NO
	},
	{	SCC_CIPHER_ID_ARIA,
		{0xB6,0x38,0x13,0x8E,0x66,0xB1,0x45,0x5B, 0x17,0xA1,0xB6,0x89,0x4A,0x0B,0xA8,0x60}, 16,
		{0x6D,0x8D,0x63,0x16,0x52,0xE1,0x83,0x84, 0xEF,0x7D,0xA0,0xC4,0x75,0x5E,0x90,0x91}, 16,
		{0x60,0x9A,0xC9,0xD7,0x4A,0xCB,0xA7,0x25, 0xEA,0x8F,0xB1,0x4C,0xE6,0x85,0x52,0x1A,
		 0xA9,0xFB,0xF9,0x55,0xAB,0x18,0x76,0x97, 0xF2,0x5A,0xA8,0x5C,0xD9,0x44,0x55,0x5A}, 32,
		SCC_CIPHER_MODE_CBC, 
		{0x10,0x50,0x59,0x11,0xE4,0x2B,0x03,0xA2, 0xC0,0x21,0xBC,0xE4,0xF4,0xD6,0xE9,0xB5}, 16,
		SCC_CIPHER_PADDING_NO
	},
	{	SCC_CIPHER_ID_ARIA,
		{0x7B,0xC7,0x9B,0xE4,0xEC,0x9C,0xE6,0xE5, 0x83,0x46,0xD7,0x83,0x91,0xA6,0x5B,0x4D}, 16,
		{0x60,0x5D,0x10,0xA5,0x83,0xE5,0xA0,0x92, 0x91,0xCF,0xA0,0x1D,0x58,0x8C,0x96,0x10}, 16,
		{0x64,0x96,0x91,0xD6,0x95,0x22,0xD0,0xB5, 0x6A,0x8B,0x1D,0x78,0x61,0x28,0x02,0xD4}, 16,
		SCC_CIPHER_MODE_CTR, 
		{0x6B,0xF4,0x1F,0x3A,0x42,0x91,0x1D,0xFE, 0xFD,0x8D,0xE4,0xB8,0xE2,0xE5,0x0E,0xEB}, 16,
		SCC_CIPHER_PADDING_NO
	},
	{	SCC_CIPHER_ID_ARIA,
		{0x83,0x46,0xD7,0x83,0x91,0xA6,0x5B,0x4D, 0x78,0x62,0x11,0xAE,0x06,0xE5,0x47,0x15}, 16,
		{0xC9,0xD8,0x90,0x58,0x8E,0xE4,0x1B,0xF5, 0x1D,0xD0,0x70,0xEC,0x74,0x6B,0x15,0x2E}, 16,
		{0x64,0x96,0x91,0xD6,0x95,0x22,0xD0,0xB5, 0x6A,0x8B,0x1D,0x78,0x61,0x28,0x02,0xD4,
		 0x6B,0xF4,0x1F,0x3A,0x42,0x91,0x1D,0xFE}, 24,
		SCC_CIPHER_MODE_CTR, 
		{0xFD,0x8D,0xE4,0xB8,0xE2,0xE5,0x0E,0xEB, 0x7B,0xC7,0x9B,0xE4,0xEC,0x9C,0xE6,0xE5}, 16,
		SCC_CIPHER_PADDING_NO
	},
	{	SCC_CIPHER_ID_ARIA,
		{0x3B,0x8C,0x10,0xCE,0xA5,0x18,0x48,0xCF, 0xEC,0xAC,0x92,0x1C,0xBC,0x51,0xA4,0x27}, 16,
		{0xA3,0xB5,0x9E,0x61,0x32,0x71,0x05,0xF3, 0xA5,0x92,0x73,0xA5,0x2E,0xFC,0x2E,0x4C}, 16,
		{0x67,0x93,0x5A,0xD6,0xDF,0x79,0xF8,0x46, 0xEA,0x87,0x89,0xA4,0xDC,0xCA,0xB3,0x8E, 
		 0x2D,0xED,0x46,0x1F,0xDA,0x0A,0xC4,0x64, 0x08,0xC0,0x21,0x14,0xEA,0x86,0xC7,0x7B}, 32,
		SCC_CIPHER_MODE_CTR, 
		{0xE6,0x3E,0xDD,0xB8,0xF3,0x0E,0xC9,0x28, 0x46,0x6B,0xF3,0x22,0x2D,0x76,0xCC,0xE5}, 16,
		SCC_CIPHER_PADDING_NO
	}
	
};


static
int
SC_ARIA_SelfTest()
{
	U8	cipher[64], plain[64];
	U32	cipherLength, plainLength;
	int	i, it;
	int	retCode;

	it = sizeof(tv_cipher)/sizeof(SC_CIPHER_TV);
	for (i=0; i<it; i++) {

		// ARIA 암호화
		retCode = SC_ARIA_Encrypt(cipher, &cipherLength, tv_cipher[i].plain, tv_cipher[i].plainLength,
									  tv_cipher[i].key, tv_cipher[i].keyLength, tv_cipher[i].iv,tv_cipher[i].ivLength, tv_cipher[i].modeID, tv_cipher[i].paddingID);
		if (retCode != 0) goto end;

		// 암호문과 벡터값을 비교
		if ((cipherLength != tv_cipher[i].cipherLength) ||
			(memcmp(cipher, tv_cipher[i].cipher, tv_cipher[i].cipherLength) != 0)) {
			retCode = SCC_SELFTEST_ERROR_ALGORITHM_ARIA_KAT; 
			goto end;
		}

		// ARIA 복호화
		retCode = SC_ARIA_Decrypt(plain, &plainLength, tv_cipher[i].cipher, tv_cipher[i].cipherLength,
									  tv_cipher[i].key, tv_cipher[i].keyLength, tv_cipher[i].iv,tv_cipher[i].ivLength, tv_cipher[i].modeID, tv_cipher[i].paddingID);
		if (retCode != 0) goto end;

		// 복호문과 평문 벡터값을 비교
		if ((plainLength != tv_cipher[i].plainLength) ||
			(memcmp(plain, tv_cipher[i].plain, tv_cipher[i].plainLength) != 0)) {
			retCode = SCC_SELFTEST_ERROR_ALGORITHM_ARIA_KAT; 
			goto end;
		}
	}

	retCode = 0;

end:
	// 파라미터 제로화
	SC_Memzero(cipher, 0x00, sizeof(cipher));
	SC_Memzero(plain, 0x00, sizeof(plain));

	return retCode;
}

/**
 *
 *
 *
 */

typedef struct {
	U8		input[64];
	U32		inputLength;
	U8		hash[64];
	U32		hashLength;
} SC_HASH256_TV;

static const
SC_HASH256_TV	tv_hash_256[] = {
	// SHA256
	{	{0xF2,0x52,0xCF,0xED,0x7E,0xFC,0x20,0x48, 0xC2,0x70,0x42,0xAC,0x81,0xB6,0x2A,0x03, 
	     0x8B,0xAC,0x51,0xB7,0x33,0xA7,0xC3,0x75, 0x02,0x5D,0x72,0x31,0xAD,0x03,0xD1,0x6A}, 32,
		{0xCB,0x29,0x19,0x38,0x30,0xB3,0x3D,0x14, 0xC4,0x57,0xB4,0x80,0xF1,0x61,0x4A,0x43, 
		 0x88,0x28,0xC2,0x6E,0xCA,0x49,0x82,0xD4, 0xEA,0xFD,0x35,0x3C,0x0D,0xE7,0xEE,0x20}, 32
	},
	{	{0xB2,0xF4,0x40,0x95,0x9D,0x5D,0xC0,0x1E, 0x23,0xAA,0x84,0x15,0xB4,0xD5,0xAA,0xEF, 
	     0x80,0x9E,0x01,0x11,0xEA,0x31,0x1A,0x93, 0x39,0x03,0xA2,0x44,0x91,0xFD,0xEE,0xEE, 
		 0x23,0xDC,0xD8,0xDB,0xA0,0xD8,0xCA,0x97, 0xF3,0x83,0x18,0xF8,0x2F,0xF5,0x93,0x5C, 
		 0xC6,0x26,0x5B,0x32,0xFD,0x9B,0xF4,0xBC, 0x9C,0x45,0x9C,0x12,0xEA,0xA6,0xDC,0x6B}, 64,
		{0xE1,0xC2,0x63,0x0D,0xBA,0x60,0x70,0x6C, 0x43,0xE0,0x17,0x6E,0x9F,0xCB,0x8E,0x34, 
		 0x50,0x92,0x0C,0xD5,0x8E,0xD9,0xEE,0x45, 0x1E,0xED,0x1D,0x5F,0x48,0xD7,0xC4,0xF2}, 32
	}
};


static
int
SC_Hash256_SelfTest()
{
	U8		hash[64];
	U32		hashLength;
	int		i, it;
	int		retCode;

	it = sizeof(tv_hash_256)/sizeof(SC_HASH256_TV);
	for (i=0; i<it; i++) {
		// SHA256 해쉬 생성
		retCode = SC_SHA256_Digest(hash, &hashLength, tv_hash_256[i].input, tv_hash_256[i].inputLength);
		if (retCode != 0) goto end;

		// 출력값을 벡터값과 비교
		if ((hashLength != tv_hash_256[i].hashLength) ||
			(memcmp(hash, tv_hash_256[i].hash, tv_hash_256[i].hashLength) != 0)) {
			retCode = SCC_SELFTEST_ERROR_ALGORITHM_HASH_SHA256_KAT; 
			goto end;
		}
	}

	retCode = 0;

end:
	return retCode;
}

/**
 *
 *
 *
 */


typedef struct {
	U8		input[64];
	U32		inputLength;
	U8		hash[64];
	U32		hashLength;
} SC_HASH512_TV;

static const
SC_HASH512_TV	tv_hash_512[] = {
	// SHA512
	{	{0xBE,0x84,0xC4,0x7D,0x58,0x68,0x41,0xC9, 0x6A,0x87,0x1F,0xBC,0x22,0xED,0x89,0xEC, 
	     0x8D,0xFE,0xA3,0xF7,0xA1,0x67,0xB6,0x16, 0x80,0x54,0x8D,0xF4,0xFB,0xE4,0x1F,0xC0}, 32,
		{0x49,0xF3,0x25,0x04,0x2C,0x2D,0x60,0x59, 0x74,0x4B,0x1F,0xC6,0xFB,0xD2,0xEC,0x8D, 
		 0x23,0x49,0x58,0x48,0x13,0x82,0xA6,0x90, 0x0C,0x4A,0x2F,0xF8,0x12,0xDB,0x2A,0x4C, 
		 0xA3,0x71,0xAD,0x8E,0x45,0x1C,0xEE,0x6A, 0x07,0xA4,0x25,0xE4,0xC9,0x8F,0x32,0xBE, 
		 0xB4,0x90,0x69,0x99,0x20,0x84,0xC1,0x6E, 0x24,0xE7,0x05,0x88,0xE0,0xFD,0x1A,0x9B}, 64
	},
	{	{0xCF,0x13,0xD0,0x27,0xE9,0x02,0x8B,0xA5, 0xA5,0x72,0x90,0xD3,0xA7,0x02,0x5A,0x4E, 
	     0xEC,0x52,0x52,0xEC,0xC3,0x00,0xF2,0x4C, 0x18,0xD6,0x2B,0xB2,0xF8,0x41,0x04,0x12, 
		 0x52,0x05,0x85,0x6B,0xFB,0x30,0xD3,0x57, 0xF5,0x4C,0x9C,0xDF,0xF1,0xD9,0xB5,0x93, 
		 0x12,0xFB,0x02,0xDB,0xF4,0x6F,0x97,0x88, 0xED,0xC3,0x1C,0xAE,0x93,0xC7,0x76,0xB6}, 64,
		{0x51,0x6F,0x07,0xBC,0x40,0x4C,0xF6,0x63, 0x6B,0x59,0x2C,0x11,0xBD,0xCD,0xBD,0xC0, 
		 0xBA,0x90,0x67,0x90,0x88,0xB1,0xDB,0xA9, 0x94,0xE4,0xEE,0x4C,0x5D,0xA7,0xAE,0x82, 
		 0x02,0x65,0x17,0xD6,0x72,0x22,0x42,0x25, 0x6C,0xAA,0xC2,0xEE,0xB9,0xB7,0xF2,0x4E, 
		 0x2A,0x6D,0xC9,0x26,0x83,0xAF,0xA0,0x03, 0xA4,0xFB,0xE6,0x19,0x6A,0x0F,0x34,0x2E}, 64
	}
};

static
int
SC_Hash512_SelfTest()
{
	U8		hash[64];
	U32		hashLength;
	int			i, it;
	int		retCode;

	it = sizeof(tv_hash_512)/sizeof(SC_HASH512_TV);
	for (i=0; i<it; i++) {
		// SHA512 해쉬 생성
		retCode = SC_SHA512_Digest(hash, &hashLength, tv_hash_512[i].input, tv_hash_512[i].inputLength);
		if (retCode != 0) goto end;

		// 출력값을 벡터값과 비교
		if ((hashLength != tv_hash_512[i].hashLength) ||
			(memcmp(hash, tv_hash_512[i].hash, tv_hash_512[i].hashLength) != 0)) {
			retCode = SCC_SELFTEST_ERROR_ALGORITHM_HASH_SHA512_KAT; 
			goto end;
		}
	}

	retCode = 0;

end:
	return retCode;
}


/**
 *
 *
 *
 */

typedef struct {
	U8		input[128];
	U32		inputLength;
	U8		key[32];
	U32		keyLength;
	U8		mac[32];
	U32		macLength;
} SC_HMAC_TV_256;

static const
SC_HMAC_TV_256	tv_mac_256[] = {
	// HMAC
	{	{0x8E,0xA0,0x04,0x3C,0xD5,0xF6,0xC0,0x0C, 0x9C,0x41,0x3F,0xB0,0x8F,0x0D,0x2C,0x37, 
	     0x52,0x01,0xE3,0x9C,0xC1,0x11,0xD6,0x9C, 0x7C,0xF5,0x2F,0xC5,0xA3,0xD9,0xB7,0xD0, 
		 0xDE,0x56,0xF6,0x30,0xA1,0xA1,0x9C,0xEB, 0xAE,0x02,0x1F,0xA9,0xDB,0x88,0xA6,0x0A, 
		 0x15,0xFC,0x26,0x3D,0xA5,0x13,0xCA,0xCF, 0xB2,0xE7,0x99,0xC0,0x07,0xA8,0x53,0xDC, 
		 0x17,0x8F,0x9B,0x48,0x3E,0x14,0x5B,0x5C, 0x4A,0x61,0x65,0xB0,0x3A,0x06,0x56,0x7A, 
		 0x46,0xEE,0xC0,0x17,0x1F,0x92,0x88,0xE7, 0x77,0x6C,0x8C,0x5E,0xC4,0xAF,0x89,0x58, 
		 0x41,0x35,0x3D,0xAD,0x36,0xB9,0xC8,0x06, 0x7A,0x46,0x58,0xEF,0x36,0xEF,0x05,0x2D, 
		 0xEB,0xC1,0xFA,0x51,0xB7,0xF6,0xD6,0x8D, 0xD4,0x6B,0x52,0xC7,0x61,0x55,0x23,0xEC}, 128,
		{0xF4,0x16,0xB0,0x0C,0xEC,0x24,0xE2,0xA6, 0xCE,0xAC,0x07,0x44,0x0F,0xD8,0xED,0x8B}, 16,
	    {0xDD,0x3C,0xD5,0xC3,0xA0,0xB8,0x23,0x55, 0x98,0x5B,0xBF,0x88,0x16,0xC1,0xF2,0x02, 
	     0x27,0x63,0x35,0x2D,0x73,0x33,0xDE,0xAC, 0x68,0x03,0xE8,0xE0,0xCB,0x06,0xE3,0xFE}, 32
	},
	{	{0x6D,0xE1,0xA6,0x25,0xB2,0x9E,0x0F,0x4F, 0x4B,0xD5,0xAA,0xFE,0xFA,0xCB,0xFA,0xBA, 
	     0xFD,0x5D,0xB4,0x77,0x48,0x3A,0x22,0x66, 0x13,0x4F,0xC5,0x11,0x94,0x83,0x3E,0xA7, 
		 0x0E,0xA5,0x6F,0x94,0x0A,0xA2,0xDD,0x55, 0xE4,0xFC,0x58,0x8B,0x8A,0x77,0xDF,0x4E, 
		 0x81,0x16,0xBE,0xC3,0x29,0x45,0xF9,0xF1, 0x41,0x58,0xED,0xD0,0xAD,0x34,0x35,0xA3, 
		 0x77,0x4C,0xCB,0x88,0x15,0xD0,0x6F,0x4E, 0xEA,0x20,0x4D,0x86,0x0F,0x87,0xDA,0xDD, 
		 0x52,0x26,0xFF,0xA9,0x7F,0x2E,0x79,0xC1, 0xDF,0x53,0x80,0x92,0xFF,0x7D,0xA6,0x6F, 
		 0xB2,0xC0,0x03,0x29,0x59,0x8E,0x8F,0xE0, 0x62,0x2B,0xCF,0x18,0x0F,0x62,0xB4,0x0F, 
		 0x79,0x77,0xC0,0x4F,0xD4,0x5C,0x6A,0x7F, 0xF4,0x27,0xC4,0x7E,0x10,0xC4,0x5B,0xB3}, 128,
		{0x8E,0x1A,0x2A,0x12,0x84,0x5B,0x3E,0x91, 0x14,0xC5,0xF9,0xB8,0xD7,0x19,0x65,0x7A, 
		 0xBE,0x15,0x9B,0x9A,0x56,0xA3,0x2B,0x79, 0x4B,0x51,0xBE,0x2D,0x2C,0x01,0xFA,0xD2}, 32,
	    {0x5F,0xB1,0x17,0x4D,0xCF,0x41,0xFD,0x02, 0xBB,0x68,0xAA,0x46,0xB6,0xDB,0xA5,0x74, 
	     0x7E,0x5D,0xA0,0xAA,0x28,0x42,0x73,0xB0, 0x87,0x53,0xB4,0xD0,0x8D,0x41,0x47,0x6E}, 32
	}
};

static
int
SC_HMAC256_SelfTest()
{
	U8		mac[32];
	U32		macLength;
	int			i, it;
	int	retCode;

	it = sizeof(tv_mac_256)/sizeof(SC_HMAC_TV_256);
	for (i=0; i<it; i++) {
		retCode = SC_HMAC_SHA256(mac, &macLength, tv_mac_256[i].key, tv_mac_256[i].keyLength, tv_mac_256[i].input, tv_mac_256[i].inputLength);
		if (retCode != 0) goto end;
		
		if (memcmp(mac, tv_mac_256[i].mac, tv_mac_256[i].macLength) != 0) {
			retCode = SCC_SELFTEST_ERROR_ALGORITHM_HMAC_SHA256_KAT; 
			goto end;
		}
	}

	retCode = 0;

end:
	// mac 생성값 제로화
	SC_Memzero(mac, 0x00, sizeof(mac));

	return retCode;
}

typedef struct {
	U8		input[128];
	U32		inputLength;
	U8		key[128];
	U32		keyLength;
	U8		mac[64];
	U32		macLength;
} SC_HMAC_TV_512;

static const
SC_HMAC_TV_512	tv_mac_512[] = {
	// HMAC
	{	{0x30,0xA6,0x36,0xDD,0x52,0x61,0xDD,0xA4, 0x0B,0x50,0x07,0x7F,0xB2,0xF6,0x7D,0x21, 
	     0xFB,0xD0,0x1A,0x0D,0x30,0x88,0x2D,0x63, 0xBD,0x6B,0x1F,0xFA,0xF2,0x1D,0x56,0xB0, 
		 0x05,0x8B,0x58,0xFE,0x56,0x22,0x34,0xD0, 0xF7,0x3F,0x1E,0x93,0x6C,0xE6,0x59,0x8F, 
		 0xAF,0xB6,0x5A,0x77,0x78,0x1C,0x2A,0x3E, 0xBA,0xC8,0x0C,0x2D,0x71,0x5D,0x60,0x33, 
		 0x9B,0x6D,0xC7,0x7C,0x84,0xA4,0x88,0x44, 0x47,0x43,0x32,0xEE,0x92,0xD0,0x83,0x50, 
		 0xA9,0x0C,0x89,0x52,0xAE,0x26,0x07,0xB7, 0x1F,0x2E,0x1A,0x3A,0xA0,0xCC,0x1C,0xDD, 
		 0xFB,0x32,0xC9,0x7E,0x65,0x4F,0xA0,0xAB, 0x03,0x46,0x8C,0xB7,0xAC,0x1E,0xC4,0x0D, 
		 0xF1,0xBB,0xF0,0xC5,0x5A,0x0D,0x8D,0x75, 0xF3,0x87,0x92,0x4A,0x07,0xD3,0x54,0x57}, 128,
		{0xA9,0x30,0xB4,0x11,0xAA,0x82,0x05,0x8A, 0x3B,0x15,0xB3,0x8A,0x64,0x68,0x93,0xA0, 
		 0x41,0xB3,0x4B,0xEA,0x4B,0x1E,0xB7,0xE6, 0xD8,0x30,0x8B,0x85,0xE6,0x8A,0x3A,0x81, 
		 0x14,0xD5,0x17,0xF1,0xF1,0xF9,0xBA,0x1B, 0x79,0x8F,0xA6,0x89,0xDD,0x9A,0x29,0x5F, 
		 0x83,0x71,0x83,0xEB,0x4E,0x00,0x4A,0x7E, 0x1F,0x30,0x0C,0x7A,0x9C,0xA4,0x37,0xAD}, 64,
	    {0x2A,0xE4,0xB6,0xF0,0x45,0xB4,0xA3,0xD9, 0xDC,0x42,0x85,0x37,0xE9,0xFE,0x97,0x1E, 
		 0xF2,0x15,0xC1,0x4F,0x67,0xE9,0xE3,0x80, 0x4E,0xF5,0x85,0x80,0x3D,0x33,0x0F,0x8E, 
		 0x34,0x62,0x4F,0x5C,0x08,0x27,0x29,0x15, 0x05,0x57,0xEB,0x19,0x6C,0x79,0x4C,0xCA, 
		 0x75,0xA7,0x85,0xAC,0x52,0x0B,0x2C,0x6F, 0x0E,0x7F,0x8C,0x81,0xD0,0x41,0xC5,0x1C}, 64
	},
	{	{0x9C,0xC3,0xB7,0xD6,0xF6,0xC9,0xAC,0x21, 0xD4,0x37,0x8A,0x50,0x2C,0xBB,0x95,0xA6, 
	     0x0C,0xBF,0xE3,0xEE,0xDB,0x99,0xC0,0x57, 0xE1,0x02,0x50,0x82,0x0A,0xCA,0x76,0xDA, 
		 0xE6,0xCA,0xF5,0x24,0xF5,0x19,0xD5,0x56, 0x22,0x83,0x09,0xAD,0x8D,0x36,0x4E,0xFA, 
		 0x8D,0xBF,0x56,0x3D,0xF6,0x35,0x26,0x74, 0x97,0xB4,0xBD,0xB5,0x07,0x0D,0xF6,0x7B, 
		 0xA2,0xBC,0xAF,0x3E,0xCE,0x1B,0x2B,0x46, 0x83,0xD5,0xB5,0xC0,0x0A,0x9C,0x86,0x12, 
		 0x04,0x1F,0xE9,0x6C,0xAF,0x36,0x9D,0x9F, 0x65,0x60,0x7B,0x33,0x65,0x70,0x58,0xB3, 
		 0xD6,0x83,0x2D,0x4C,0x09,0x35,0x76,0x97, 0xFF,0x15,0xD7,0xB2,0x2B,0x56,0x05,0x95, 
		 0x78,0xC7,0xE4,0xA3,0x8E,0x05,0xED,0x80, 0x51,0xEE,0xD3,0x23,0xAB,0x5A,0x66,0x2C}, 128,
		{0x42,0xC1,0xF3,0x7F,0xE3,0x51,0x29,0x6A, 0xBF,0x23,0xBA,0xDF,0x25,0xDE,0x03,0xD8, 
		 0xFA,0x61,0xB4,0x59,0xFF,0xFC,0x2E,0x49, 0x51,0xDF,0x30,0x80,0x36,0xD2,0xB3,0x21, 
		 0x16,0x27,0x12,0x2A,0xC8,0xED,0x6E,0x49, 0x10,0x67,0x51,0xF2,0x65,0xBD,0x91,0xAE, 
		 0xF7,0xF0,0x78,0xB6,0xF0,0x13,0x21,0xC0, 0xFA,0xB9,0x25,0x19,0x02,0xAA,0x78,0xF4, 
		 0x3C,0xDA,0x8D,0x02,0x68,0x9B,0xC1,0x42, 0x53,0x11,0xF6,0x1B,0xA0,0xE6,0x7E,0xA8, 
		 0xC8,0x40,0x3C,0x53,0x60,0xF0,0x05,0xA5, 0x9B,0xED,0x4C,0x5C,0x0F,0x00,0xFF,0xBE, 
		 0xBC,0xC0,0xAC,0x2E,0x4A,0xC1,0xE8,0xFD, 0x92,0x09,0xF1,0x82,0x60,0xC3,0x92,0x6D, 
		 0x77,0x38,0x47,0x58,0xD6,0xFA,0xA2,0x9F, 0x3A,0x62,0xED,0x72,0xE4,0x3D,0x11,0x28}, 128,
	    {0x73,0x3B,0x89,0x24,0xD9,0x1E,0x1F,0xBA, 0xF4,0x57,0x05,0x96,0x9B,0x5B,0xFB,0xDC, 
		 0xB2,0xB8,0x96,0xD4,0x23,0x8D,0xB3,0x0F, 0x07,0xAF,0x71,0xE5,0x31,0x0B,0x21,0xD4, 
		 0x48,0x4D,0x37,0x18,0x9C,0xD4,0x34,0xDF, 0x19,0x60,0x93,0xBB,0x64,0xAD,0xE3,0x18, 
		 0x2B,0x91,0x44,0x3C,0x45,0xD9,0x95,0x10, 0xF6,0x9B,0x80,0xDE,0x32,0xA6,0x0A,0xF1}, 64
	}
};

static
int
SC_HMAC512_SelfTest()
{
	U8		mac[64];
	U32		macLength;
	int			i, it;
	int	retCode;

	it = sizeof(tv_mac_512)/sizeof(SC_HMAC_TV_512);
	for (i=0; i<it; i++) {
		retCode = SC_HMAC_SHA512(mac, &macLength, tv_mac_512[i].key, tv_mac_512[i].keyLength, tv_mac_512[i].input, tv_mac_512[i].inputLength);
		if (retCode != 0) goto end;
		
		if (memcmp(mac, tv_mac_512[i].mac, tv_mac_512[i].macLength) != 0) {
			retCode = SCC_SELFTEST_ERROR_ALGORITHM_HMAC_SHA512_KAT; 
			goto end;
		}
	}

	retCode = 0;

end:
	// mac 생성값 제로화
	SC_Memzero(mac, 0x00, sizeof(mac));

	return retCode;
}


#define KEY_LEN 256
#define PT_LEN  28

#define RSA_N   "B59B261C310BB787FD7D546D2FFBDC73" \
	"3F40101ECA0D0D00F2C6AB6078AFF4D1" \
	"9523D20AB944805269521986DAF968E9" \
	"E663B79216DF5C6AEDC2EAB1F95BA042" \
	"CA467ABEEFC41D72EB3DA5F9CE4499B7" \
	"7C541B721652D8E41F8D670EA3E83BEB" \
	"FE20986D6AF54729EF8A72849382F4B0" \
	"6547B77656D289B33517242F3A006930" \
	"29CA0C5F00AB9D856E4B6CE82B1A226B" \
	"E1C230FDFA6492830ABDE8CF8B572840" \
	"6A44D6952D03A0895D11CE8F6C2F941B" \
	"04A3DBB63ED95B975DFADEA46CE97E58" \
	"C1BB865039FEC58AFB54825299922FCA" \
	"052CD29E7A7F8FB2AB42A758FC986FCC" \
	"0CE0BC603485D7E0A73F7297B21631A6" \
	"684086F0E01B2DF4551E2065DEAFC037"


#define RSA_E   "10001"

#define RSA_D   "A0FF6E85C7A54F8BABDA9422484BCC60" \
	"0F4EC7FBC3BC562EE50BE39A9EE3BEF2" \
	"9E79271882AE8BE483A2592708B1DBA4" \
	"A0AEFE6AF1040B76705A409E8F25FFA9" \
	"B6914CF840AF683C1CF8865033E0F535" \
	"896F36F5A97CC0F35C558B6B9B3BA303" \
	"D0432D5EB357C743122D76E0B9B57B1F" \
	"766A61E6F389AAB1C8FB3F04EF32B60C" \
	"905C5E07AD2B81F8D9C2839372D75E9A" \
	"16D645760A7C75A9EA2FD9A61C6F4F76" \
	"0DEDABEEE1CF1532F5E7D7AFEC5C0167" \
	"045306599C266A48C0C0342BBCD852B7" \
	"8728B3CBA520AA48EE60F5EDB37787BA" \
	"B62D4259787376089E4FE6D6B024E3A8" \
	"42C6F8F0F6D01947B5128BACC1CA87F5" \
	"E919A57D360DAE9CDEF443693D065DC1"

#define RSA_P   "C242D28C7E55DC613CD8A43E37D8A475" \
	"6DF8C1EEAAF9FC2ACE2220E67AB2551F" \
	"2EA97449DE7C6D3807B8CF7CD2F4C280" \
	"EF64DF75829D5A1D69AE4B240B9EB535" \
	"868E8F501491D2E343F594A0354F75F3" \
	"0226477486C5498413D53EE2E6ADD223" \
	"321360871706E0FC3A15268666B24F0C" \
	"F99B6A36A43A0EDB2894E5FC0392899F"

#define RSA_Q   "EF52B60AA5C8322AE44A34A8EF592C63" \
	"869745BA7276066D8734DA5658DD2BEF" \
	"624263626C3C1F8D2362FB8C7946BE33" \
	"88CD8155B724067C48F6E162BB0E0D78" \
	"35A87760C2DDCD4D1AB6A0C9C6099B88" \
	"73230EE5A94B47A981575AB85BFA12DB" \
	"FDB862F38027A219AD9BF03ED91D3CBF" \
	"8845FAD70D6CE211F0DF03E4B763F269"


// for encrypt
#define RSA_PT_ENC  "\x21\xB9\x61\xC6\xEE\xA0\xFE\x2F\x49\xCD\xCC\xA8\x98\x97\x9E\xAF\xF2\x89\xE1\x4C\xD9\xD0\x7B\x0B\x6B\x45\xC6\xAF"
#define RSA_CT_ENC	"\x61\x0A\x01\x20\x0E\xD3\x2B\xFA\xAF\xA7\x6F\xA5\xA3\x01\xA4\xA5\xB0\x6A\x60\xA2\x8A\x1F\x5A\xE1\xD2\x47\x01\xE8\x4E\x81\x03\x4C\xC9\xDE\xCB\xDB\x55\xEB\x57\x8E\x88\xF0\x5A\x85\xB2\xED\x40\x52\xD1\x62\x74\xE8\xCD\x60\xA2\xDE\xCD\xE5\xE2\x79\x05\xDA\x3F\x85\x44\xF3\x70\x13\x62\x3D\x2C\x99\xC4\x3F\x6B\x14\xA0\xF8\xF2\x01\x09\x72\xED\xFA\xD8\x8C\xEF\x46\xB5\x11\xC0\xA1\x2E\x8F\xBB\x1A\x83\x4D\x2D\xCD\xCB\x66\xC2\x8C\xC0\xBB\x77\x99\xE0\x57\xB1\x25\xCE\x72\x47\x16\x55\xC9\x0E\x64\xC7\x06\x94\x73\x12\x84\xDC\x5D\xB8\x71\x39\xEA\x94\x47\xFB\x8D\xE1\xB1\x0D\x3B\x8C\x89\xE3\xE6\x78\x54\xBD\x10\xBE\x78\x01\x6C\x5B\x40\xDE\x3A\xBD\x52\xA1\x73\x64\x3B\xAE\xEC\xCD\x86\x30\xE3\x37\x6E\x84\x40\x0D\x82\x0E\xF4\xAF\xE2\xBB\x57\x1E\x79\x54\x40\xC2\xF5\x3D\x55\x0B\xBD\x9A\x3E\xF5\xA2\xF6\x31\xC6\xF6\x8B\xA1\x84\x31\x97\xCD\x0A\x60\x97\x96\xA2\xA6\x16\xA3\x2E\x27\xDD\x18\x89\x1E\x69\xC6\xFD\x23\xC4\xAF\x97\xDD\x54\xC9\xF4\x69\x76\x6E\xEB\x6D\x1B\xA2\x38\xAB\x49\xC3\x33\x62\xDC\x52\x0F\x15\x7B\x11\xD8\x63\x1A\x87\xDF\x9D\x50\x25"

// for decrypt
#define RSA_PT_DEC "\x1E\x0C\xC7\xB7\xE6\xC4\x37\x43\xCD\x11\x5B\x7D\xD1\xF9\xA4\x13\x76\xCF\xF4\x46\xA6\x3B\xA9\x80\x29\x6B\x23\x56"
#define RSA_CT_DEC "\x76\xF4\x39\x85\x6D\x00\xBC\x4D\x85\x30\xA3\xFB\x21\x8B\xC3\xCC\x45\xF3\x91\x60\xD5\xB8\xFB\x89\x2A\x3D\x3B\x51\x0F\x24\x8D\xF1\x75\x71\xAB\x81\x85\xD9\x14\x30\x75\xDE\x42\x54\x2C\x61\x22\x61\xAA\xD3\x85\x46\x51\x16\x47\x4C\xB7\xA9\xA6\x47\xB2\x62\x57\xEE\xE5\x6C\x1D\x02\x18\x63\x9F\xB3\xFA\x28\x89\xB7\xAC\x0E\xF9\xC9\xA8\xB7\xD6\x8B\x4B\xB4\x11\x91\x5D\xF4\xAC\xB0\x4F\xB5\x10\xFD\x97\xB8\x57\x18\xA1\x87\xD8\x8C\xD6\xB5\xE5\x64\x4D\x34\xC9\xBF\xBC\x16\x33\x6F\xC2\x39\xB5\x75\x91\xFE\x53\xEC\x2F\xCE\xC4\x6E\xE9\xC2\xD6\x43\x15\xDE\xBB\xFE\x02\xCE\x1F\x91\x6D\x94\x18\x78\x98\x4B\x10\xDB\x82\xFE\x4E\x5E\xD9\xCF\x16\x81\x96\x14\x58\xBC\x5A\x28\xB0\xE1\x5E\x64\xB4\xB0\xC0\x22\xEA\xCB\x9F\xA5\xC4\x07\xEA\x3D\xE9\xD7\x26\xBA\x30\x82\x4D\xD3\x79\xEF\xD3\xA1\xE7\xD6\x45\xBF\x47\x2F\xC2\xA4\xB0\xDC\xFD\x3D\x44\xCA\x5E\xF2\x3A\x6A\xE6\x5E\xB1\x27\x8B\x18\xA8\x10\xB7\x7C\x5F\xA2\x99\x76\x5F\x34\x45\xD1\xA1\x26\xC7\xB9\x40\x9C\xC1\x7E\x03\xFD\xB6\x68\x71\x57\x4B\xFE\x08\x76\x8A\x04\xDD\x78\xE5\x8D\x0A\x64\xDF\x31\x9F\xDB"


static
int
SC_RSA_SelfTest()
{
	int retCode = 0;
	U32 length = 0;

	SC_RSA_PrivateKey *privKey = NULL;
	SC_RSA_PublicKey *pubKey = NULL;

	U8 rsa_plaintext[PT_LEN];
	U8 rsa_decrypted[PT_LEN];
	U8 rsa_ciphertext[KEY_LEN];

	// 키쌍 구조체 생성 / 설정
	privKey = SC_RSA_PrivateKey_New();
	if (privKey == NULL) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_RSA_KAT;
		goto end;
	}
	pubKey  = SC_RSA_PublicKey_New();
	if (pubKey == NULL) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_RSA_KAT;
		goto end;
	}

	SC_BIGINT_CHK( SC_Bigint_Read_String( privKey->n ,    16, RSA_N  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( privKey->e ,    16, RSA_E  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( privKey->d ,    16, RSA_D  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( privKey->p ,    16, RSA_P  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( privKey->q ,    16, RSA_Q  ) );
	
	SC_BIGINT_CHK( SC_Bigint_Read_String( pubKey->n , 16, RSA_N  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( pubKey->e , 16, RSA_E  ) );

	
	retCode = SC_RSA_Check_Privkey(privKey);
	if(retCode < 0) goto end;

	retCode = SC_RSA_Check_Pubkey(pubKey);
	if(retCode < 0) goto end;

	memcpy(rsa_plaintext, RSA_PT_ENC, PT_LEN );

	retCode = SC_RSA_Pkcs1_Encrypt(pubKey, SC_RSA_PKCS_V21, PT_LEN, rsa_plaintext, rsa_ciphertext);
	if(retCode < 0) goto end;

	if(memcmp(rsa_ciphertext, RSA_CT_ENC, KEY_LEN) != 0) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_RSA_KAT;
		goto end;
	}
	
	retCode = SC_RSA_Pkcs1_Decrypt(privKey, SC_RSA_PKCS_V21, &length, RSA_CT_DEC, rsa_decrypted, PT_LEN);
	if(retCode < 0) goto end;

	if(length != PT_LEN || memcmp(RSA_PT_DEC, rsa_decrypted, PT_LEN) != 0) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_RSA_KAT;
		goto end;
	}
	
 	retCode = 0;

end:

	// 키쌍 구조체 제거 및 제로화
	if(pubKey != NULL) {
		SC_RSA_PublicKey_Free(pubKey);
	}
	if(privKey != NULL) {
		SC_RSA_PrivateKey_Free(privKey);
	}

	return retCode;
}


// 2048 256 TTA 벡터
#define KCDSA_P   "d06eb9f275b3ac7f2970b578ad1c3173" \
"2a0126844776f95cf07b4194c6def6f4" \
"16a66751458b0667cdbc44af3f6b5877" \
"0e674a861c8febf4eea0e50450ec5272" \
"26b8470717ee768cf39cfd32bc2540d2" \
"924e0968e64d47ee4cf0ab6cd192284b" \
"826c75082e18840b67bc4cb1f1708173" \
"f08825ba4f6e5fb86a357f02c06f8283" \
"f3cd58a1ed4d3062f4a5c0d2f26e54c0" \
"fa511b5ed5cfd27019d4a90dda7aca50" \
"561397abeede9cff45ec6cf3e22dac5c" \
"af454b7b9b3b5ffe16128197768114c9" \
"cd4be4e9ecdc431a0cc0ed544fd4da1c" \
"9e98a2c3cb4297fe1d1387d81c51d492" \
"5ede6a8bbaf660ef675549b4aea5267f" \
"b5f778d5308dd69175de580ec316c4ef" 

#define KCDSA_Q   "cfefed9c75b5610fdb100d91c4cb8187" \
"a007791733128ff143ffedf97f6ffd65" 

#define KCDSA_G   "023fec34dfa5e5ce369dd782b07034af"\
"037ac18728d432045739b9861b0df1dc"\
"aeeb5c9ed3e025d83adcdae0419c158b"\
"09ee35ff84ab9caa9ed4e535f982fb99"\
"e30d319537c05780a2cf31cf6bb226c6"\
"6b7b3ed76b65dc658b216b867f186d98"\
"0d30d1a95285a081c5aba363939660a5"\
"7596c6212207e4e358b729bc079778b4"\
"f385824c0862cdce08aeb2c658c18559"\
"d3ed865cd6bed194da447fd41789c74d"\
"352ed26b56c2d128f1154f733fe71f10"\
"bf676c9f7e4268c053d13152997a2d9b"\
"fb73fccb0dcea4c132f68f282a6db325"\
"cc467fb7f1fe2da5f80fd32cae781a75"\
"74845a3d457120543987b348d5d75b1b"\
"954cba473f83951a8c1be717b953206c" 


#define KCDSA_X  "21e2cf868d004318aca87261476dfc67" \
"c198336482fe1dcb3cbb5ba0f081158a" 

#define KCDSA_Y  "44ce4c95da1ff8bfbc6b7277ccc6694e" \
"1b1e6dfacf617533354da0cf6966e156" \
"2124003db09e33309a24f87c467917ae" \
"dfeb911fd5344422063452757c40f0a0" \
"bb45acc8e462c5ac4d8dd0f92fcc80f3" \
"3e4160f598682bf571163c43bd703c2c" \
"1827db2e2336511d84520afa97dc4962" \
"40ea4a82ca2ffc646363f822d037c813" \
"8f3458a3e41bd3a023b63cc113b33ecb" \
"3fcccc5cbed325e7ec1f07e203e9aa8e" \
"451c96fbdec927d6ee741540a90673b4" \
"f2feac07b6f4eda08db28fdfaed8634e" \
"7ff40582ae33d8dbf377a7619ad1c006" \
"686337792943e6cd016d5534e4122bca" \
"18d1207579ea4c90610a1496b63c23dc" \
"996b686efeb34c361f9afdcf7e8fbf9a"

static   
	U8 KCDSA_M[] = {0x54,0x68,0x69,0x73,0x20,0x69,0x73,0x20, 0x61,0x20,0x74,0x65,0x73,0x74,0x20,0x6d,
	                0x65,0x73,0x73,0x61,0x67,0x65,0x20,0x66, 0x6f,0x72,0x20,0x4b,0x43,0x44,0x53,0x41,
					0x20,0x75,0x73,0x61,0x67,0x65,0x21};

static 
	U8 KCDSA_RS[] = {0x59,0x49,0x00,0x77,0xf9,0x8c,0x21,0x78, 0x85,0x09,0xcb,0x47,0x8c,0xcd,0xe7,0x7a,
	                 0x4f,0xb5,0x41,0x4e,0x13,0xcf,0x92,0x81, 0xcb,0x80,0x97,0x5b,0x33,0x70,0xd9,0x7d,
                     0x18,0x5f,0x21,0xb5,0xdb,0xf4,0x25,0x5b, 0x95,0x4a,0x4d,0x62,0xcf,0x36,0x3c,0x32,
					 0x73,0x21,0x11,0x47,0xcb,0xa0,0x54,0xe8, 0x3a,0x87,0xda,0x2d,0xd7,0xe0,0x74,0x1d};


static
int
SC_KCDSA_SelfTest()
{
	int retCode = 0;

	U8 signature[4096] = {0x00,};
	U32 signatureLength = 0;
		
	SC_PKEY_PrivateKey privKey;
	SC_PKEY_PublicKey  pubKey;
	SC_PKEY_Parameters params;
	SC_PKEY_SignParam  signParam;
	SC_BIGINT x;
	SC_BIGINT y;
	
	params.pkeyID = privKey.pkeyID = pubKey.pkeyID = SC_PKEY_ID_KCDSA;
	
	// KCDSA 파라미터 생성 / 설정
	retCode = SC_KCDSA_CreateKeyObject((SC_KCDSA_Parameters **)&params.params);
	if(retCode < 0) goto end;
	
	SC_Bigint_New(&x);
	privKey.privKey = &x;

	SC_Bigint_New(&y);
	pubKey.pubKey = &y;

	SC_BIGINT_CHK( SC_Bigint_Read_String( &((SC_KCDSA_Parameters *)params.params)->KCDSA_p , 16, KCDSA_P  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( &((SC_KCDSA_Parameters *)params.params)->KCDSA_q , 16, KCDSA_Q  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( &((SC_KCDSA_Parameters *)params.params)->KCDSA_g , 16, KCDSA_G  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( &x , 16, KCDSA_X  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( &y , 16, KCDSA_Y  ) );
	signParam.kcdsa.pkPubKey = &pubKey;

	// 전자서명 생성
	retCode = SC_PKEY_Sign(signature, &signatureLength, SC_PKEY_MSGID_MESSAGE, KCDSA_M, sizeof(KCDSA_M), SC_PKEY_SIGNID_KCDSA_SHA256, &privKey, &params, &signParam);
	if(retCode < 0) goto end;

	// 생성된 서명문을 벡터값과 비교
	if(memcmp(signature, KCDSA_RS, signatureLength) != 0) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_KCDSA_KAT;
		goto end;
	}

	// 서명 검증
	retCode = SC_PKEY_Verify(KCDSA_RS, sizeof(KCDSA_RS), SC_PKEY_MSGID_MESSAGE, KCDSA_M, sizeof(KCDSA_M), SC_PKEY_SIGNID_KCDSA_SHA256, &pubKey, &params, &signParam);
	if(retCode < 0) goto end;

end:
	// 파라미터 제거 및 제로화
	SC_KCDSA_DestroyKeyObject((SC_KCDSA_Parameters **)&params.params);
	
	return retCode;
}



//
// HASH_DRBG 자가시험 코드
//

// 초기화용 엔트로피 테스트 벡터
U8 _entropy1[55] = {
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 
		0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 
		0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36};

// 외부갱신용 엔트로피 테스트 벡터
U8 _entropy2[55] = {
		0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
		0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 
		0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 
		0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6};

U8 _entropy3[55] = {
		0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 
		0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 
		0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 
		0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6};

// 초기화용 논스
static 
	U8 _nonce[8] = {
		0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27};

// 초기화용 개별화 문자열
static 
	U8 _personal[55] = {
		0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
		0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 
		0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76};

// 초기화 함수에서 출력된 V
static 
	U8 _V1[55] = {
		0xA3, 0xE9, 0x4E, 0x39, 0x26, 0xFD, 0xA1, 0x69, 0xC3, 0x03, 0xD6, 0x64, 0x38, 0x39, 0x05, 0xE0, 
		0xD7, 0x99, 0x62, 0xD1, 0x65, 0x44, 0x6D, 0x63, 0xBD, 0xA6, 0x54, 0xD1, 0x32, 0xF7, 0x2D, 0xB4, 
		0x71, 0x56, 0x4B, 0x45, 0x6F, 0xF2, 0xEE, 0xC8, 0x36, 0x42, 0x2A, 0xCC, 0x5A, 0x02, 0x99, 0x35, 
		0xA7, 0x99, 0x29, 0x90, 0x94, 0xA1, 0xCA};

// 외부갱신 함수에서 출력된 V
static 
	U8 _V2[55] = {
		0x06, 0x1E, 0x90, 0x12, 0x93, 0x58, 0x25, 0x4D, 0x14, 0xFC, 0x25, 0x43, 0x3D, 0x1E, 0xFF, 0xCF, 
		0x56, 0x5F, 0xF7, 0x73, 0x36, 0x41, 0xB8, 0xEC, 0xF0, 0xAA, 0x01, 0x84, 0x4A, 0x5F, 0x90, 0xA2, 
		0xB0, 0xD5, 0x1B, 0x88, 0x47, 0xB2, 0xE7, 0x09, 0x58, 0x68, 0x8E, 0x3A, 0xE7, 0x89, 0x78, 0xE5, 
		0xAB, 0xA0, 0x4D, 0xEB, 0x60, 0x49, 0x3B};

// 초기화 함수에서 출력된 C
static 
	U8 _C1[55] = {
		0x44, 0x74, 0x8A, 0x78, 0xB1, 0x6E, 0x75, 0x55, 0x9F, 0x88, 0x1D, 0x51, 0xC1, 0x5D, 0xFE, 0x6C, 
		0x52, 0xCF, 0xB0, 0xBB, 0x71, 0x62, 0x01, 0x69, 0xC7, 0x93, 0x34, 0x27, 0x67, 0xE7, 0xF8, 0x87, 
		0x5F, 0x42, 0xCB, 0x6A, 0x20, 0xC8, 0x9D, 0x7C, 0x6E, 0xF3, 0xDC, 0x61, 0x0D, 0x8F, 0xF2, 0x03, 
		0xD6, 0x76, 0x6C, 0xED, 0x19, 0x19, 0xD0};

// 외부갱신 함수에서 출력된 C
static
	U8 _C2[55] = {
		0xFB, 0xAF, 0xCE, 0x5B, 0xB9, 0x4C, 0x86, 0xF9, 0x24, 0xDE, 0x3E, 0x0A, 0xE7, 0xE5, 0x92, 0x46, 
		0xFF, 0x34, 0x6B, 0x5B, 0x2E, 0x61, 0x66, 0x47, 0xCB, 0x34, 0x5A, 0x89, 0xE9, 0xAF, 0x46, 0x4F, 
		0xCC, 0x88, 0x80, 0xAC, 0xC5, 0xEE, 0x70, 0x8D, 0xEF, 0xD0, 0x67, 0xF3, 0xAF, 0x61, 0x2E, 0xFD, 
		0x47, 0xCB, 0x07, 0x9E, 0xCE, 0x63, 0x3A};

// 추가입력 : 출력생성 함수
static 
	U8 _AddInput1[55] = {
		0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 
		0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 
		0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
		0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96};

// 추가입력 : 외부갱신 함수
static 
	U8 _AddInput2[55] = {
		0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 
		0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 
		0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 
		0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6};

// 출력값
static 
	U8 _RandOut1[64] = {
		0xE0, 0xB9, 0x7C, 0x82, 0x12, 0x68, 0xFD, 0x3B, 0xB2, 0xCA, 0xBF, 0xD1, 0xF9, 0x54, 0x84, 0x78, 
		0xAE, 0x8A, 0x60, 0x41, 0x7F, 0x7B, 0x09, 0x4A, 0x26, 0x13, 0x95, 0x46, 0x06, 0x2B, 0x52, 0x1C, 
		0xFD, 0x33, 0xE4, 0xE3, 0x9B, 0x9D, 0xCD, 0x0A, 0x3D, 0xA1, 0x52, 0x09, 0xC7, 0x2A, 0xDB, 0xE5, 
		0x8C, 0x20, 0xAB, 0x34, 0x07, 0x02, 0x69, 0x51, 0x29, 0x7A, 0xD2, 0x54, 0x30, 0x75, 0x53, 0xA5};


static
int
SC_DRBG_SelfTest()
{
	SC_HashDRBG_CONTEXT	ctx;
	U8 buf[1024] = {0x00,};
	int len = 0, retCode;

	//
	// 1. 초기화 함수 시험
	retCode = SC_HashDRBG_Init(&ctx, _personal, sizeof(_personal), _nonce, sizeof(_nonce));
	if (retCode != 0) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}

	// 출력값 비교 : V, C
	if (memcmp(_V1, ctx.V, ctx.vLen)) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}

	if (memcmp(_C1, ctx.C, ctx.cLen)) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}

	//
	// 2. 출력생성 함수 시험
	len = 64;
	retCode = SC_HashDRBG_Generate(&ctx, buf, len, _AddInput1, sizeof(_AddInput1), 0); 
	if (retCode != 0) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}

	// 출력값 비교 : 첫번째출력
	if (memcmp(_RandOut1, buf, len)) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}

	//
	// 3. 외부갱신 함수 시험
	retCode = SC_HashDRBG_Reseed(&ctx, _AddInput2, sizeof(_AddInput2)); 
	if (retCode != 0) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}

	// 출력값 비교 : V, C
	if (memcmp(_V2, ctx.V, ctx.vLen)) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}
	if (memcmp(_C2, ctx.C, ctx.cLen)) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}

	retCode = 0;

end:
	// 파라미터 제로화
	SC_Memzero(&ctx, 0x00, sizeof(ctx));
	return retCode;
}


#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/types.h>

int _mix(unsigned char *output, unsigned char *a, unsigned char *b, int length)
{
	int i=0;

	for(i=0; i<length; i++) {
		if((i/8) % 2 == 1) {
			output[i] = a[i];
		}else {
			output[i] = b[i];
		}
	}

	return length;
}

static U8	g_cmvp_hmac_key[20] = { 
	0x81,0xc7,0x94,0x55, 0xa2,0x09,0x1c,0x29, 0x36,0xb2,0x3c,0x64, 0x9c,0xb0,0x9a,0x6b,
	0xcb,0xb3,0x48,0xe0,
};

extern HANDLE	g_crypto_hmodule;

static U8 INTE_KCDSA_P[] = {0xE6,0xF5,0xEA,0xF8,0x99,0xF8,0x13,0x56, 0xA8,0xBD,0x97,0x64,0xDA,0x04,0x68,0x67, 
							0x44,0x38,0xD7,0xC4,0x3A,0xCA,0xA4,0xAC, 0x2D,0xCC,0x98,0xBF,0x68,0xA1,0x45,0x0B, 
							0x48,0x1C,0x0B,0x3B,0x01,0x1A,0x18,0x2B, 0x8C,0xC7,0x5C,0xD7,0xDE,0x92,0x4E,0x34, 
							0x37,0x07,0x6B,0x8A,0xC4,0x8B,0xBD,0x6A, 0xDC,0x6F,0x66,0xBE,0xA0,0x2F,0x18,0xEE, 
							0x3D,0xEC,0x51,0x17,0x6D,0x29,0xB8,0x61, 0xE6,0x4C,0xBF,0x92,0x1F,0xEE,0xA3,0xF4, 
							0x3D,0x66,0x04,0x9B,0x52,0xCE,0xA2,0x6B, 0x3E,0x5F,0x1F,0xEE,0xAB,0x85,0xE8,0xFC, 
							0xC2,0xB5,0xC5,0x17,0x79,0x2F,0x07,0x3D, 0x3A,0xAF,0x7B,0x78,0xA8,0x7A,0x84,0xC0, 
							0x6E,0xEA,0x17,0x5A,0xE9,0x5C,0x2E,0x97, 0xD9,0x53,0xD0,0x60,0x2E,0xA9,0x7F,0xFD, 
							0x67,0x99,0x39,0x20,0xFE,0x9A,0x5A,0x10, 0x26,0xBC,0x5E,0x4B,0x5C,0x6C,0x03,0x33, 
							0x74,0x36,0xB9,0x2A,0x21,0x08,0xF7,0xF6, 0xA2,0x4F,0x93,0xB2,0xF0,0x1D,0x38,0x89, 
							0xA4,0x54,0x9A,0x20,0x6D,0x07,0x4A,0x6C, 0xA6,0x6E,0x54,0x72,0xDF,0x28,0xC6,0xDB, 
							0xA9,0x0C,0x7B,0x93,0xC3,0x1B,0x90,0xCE, 0xE9,0x89,0xA9,0xE7,0xF5,0x9A,0x0C,0x03, 
							0xF2,0x87,0xBE,0x0C,0xA7,0x3E,0x29,0x57, 0x92,0x00,0xCB,0x39,0xD4,0x54,0x9F,0xB5, 
							0x31,0x64,0x9A,0x81,0x0B,0xB9,0x8A,0xCB, 0x75,0xC6,0x4C,0x7E,0xCB,0x7C,0x34,0xCF, 
							0xF3,0x7F,0x28,0x69,0x38,0x3E,0x1F,0xA3, 0x6C,0x10,0x77,0x4D,0x4D,0x00,0xB1,0x01, 
							0x9B,0xF6,0xE2,0x84,0x3E,0x95,0x8F,0x31, 0xEE,0x7A,0x1C,0x03,0x23,0x89,0x64,0xC5};

static U8 INTE_KCDSA_Q[] = {0xF4,0xFC,0xCF,0xDA,0x7A,0xD5,0x86,0x04, 0x98,0x40,0x0E,0x10,0x34,0x75,0xA5,0x85, 
							0x4D,0x25,0x6D,0xA6,0xB4,0xA9,0x39,0x09, 0xCA,0xB0,0x47,0x2F,0xBE,0xB8,0x45,0x24};

static U8 INTE_KCDSA_G[] = {0x66,0xFB,0x80,0x49,0x81,0x17,0x9A,0xDE, 0xA3,0xCF,0x7B,0xED,0x2C,0x4A,0x4F,0x8F, 
							0xED,0x0D,0x0F,0xC6,0x51,0x6E,0xE5,0x05, 0x8E,0x00,0x0D,0x95,0x39,0xF2,0xF0,0x40, 
							0xB6,0x90,0x7D,0xFA,0xDE,0xA5,0xB0,0x75, 0x2D,0x34,0xF2,0x78,0xFF,0xCA,0x8B,0x59, 
							0x78,0x64,0xE2,0x44,0x41,0xC9,0xD7,0xE1, 0x01,0x19,0x34,0xF6,0x7D,0x49,0xEF,0x9A, 
							0x70,0xDB,0x73,0xEF,0x52,0xE8,0x18,0xF1, 0xE6,0x05,0xD9,0x6C,0xC7,0x5B,0x70,0x60, 
							0xE3,0x06,0xD2,0x66,0xB2,0x33,0xBF,0xB0, 0x37,0x51,0xB4,0x1B,0xB5,0xDE,0x16,0x01, 
							0x3E,0x51,0xB7,0x92,0xB6,0x21,0x3A,0x3B, 0x5C,0xB6,0x24,0xB0,0x2A,0xBF,0x37,0x79, 
							0x0F,0xC1,0xF2,0x60,0xA9,0x2F,0x69,0x35, 0x70,0x41,0x4F,0xC0,0x1E,0x77,0xB5,0x8B, 
							0xE8,0x83,0xB6,0x19,0xF3,0x61,0x8C,0x01, 0x1F,0xB2,0x8A,0xA1,0xD4,0xB6,0x71,0x92, 
							0x05,0xAD,0x3A,0x4A,0x10,0x59,0x5C,0xC8, 0xEF,0x81,0x33,0x48,0xD8,0xC4,0x03,0x79, 
							0xF8,0x37,0x59,0xAD,0xE2,0xCC,0xB2,0xF7, 0x90,0x87,0xAD,0xA9,0xBF,0x03,0x22,0x3F, 
							0xFD,0x78,0x80,0x6B,0x5D,0xAF,0x67,0xBC, 0xEC,0xDF,0x1C,0x0E,0xC6,0x2A,0x5F,0x5C, 
							0xE0,0xA0,0x68,0xC6,0x1D,0xA5,0xA9,0x17, 0xFF,0x26,0xE4,0x8A,0xB5,0xA6,0x98,0x1C, 
							0x57,0x39,0x01,0x26,0x3D,0x8E,0x16,0xD6, 0xCE,0x6D,0x0E,0xFC,0xB8,0x5A,0x01,0x58, 
							0xAC,0xEA,0x7C,0x9A,0x03,0xFB,0xD0,0x0B, 0xF5,0x8F,0xAC,0xED,0x12,0x25,0x6F,0x48, 
							0x59,0xA4,0x4B,0x27,0xB0,0x3F,0x78,0x62, 0x99,0xE2,0xA0,0xB0,0xCC,0x31,0x11,0x00};

static U8 INTE_KCDSA_Y[] = {0x3F,0xBD,0x17,0x13,0xD8,0x9E,0x30,0x41, 0xE2,0x3B,0x87,0x79,0x35,0x47,0x2E,0xD2, 
							0x5E,0x6D,0xAF,0xB7,0x74,0xFA,0x43,0xFE, 0x88,0x26,0x44,0xDF,0xC4,0x68,0x7A,0xE2, 
							0x29,0x5F,0xDD,0x63,0x79,0xFD,0xA1,0xE2, 0xD3,0xB1,0xB8,0xF4,0xAF,0x94,0x65,0x29, 
							0x79,0xFD,0x06,0xC7,0x86,0x4C,0x7E,0xD0, 0x4E,0x28,0xDC,0x16,0x64,0xFF,0x8E,0xDF, 
							0xF0,0xD9,0xB7,0x08,0xDE,0xAC,0x77,0xD6, 0x21,0x3D,0x23,0xF5,0x82,0x7E,0x13,0xF0, 
							0x2E,0xD2,0xBD,0xAF,0xFB,0xF6,0x9A,0x1E, 0x04,0x12,0x78,0x37,0x15,0x4D,0xDC,0x82, 
							0xB2,0xFC,0x4E,0x1E,0xC1,0x4E,0x0B,0xF8, 0x1D,0x70,0x7C,0x5D,0xEE,0x05,0xF4,0x1E, 
							0x74,0x51,0x04,0xDA,0x94,0x6F,0xFD,0x70, 0x79,0x7F,0x17,0x7A,0x3E,0xC8,0xE4,0x42, 
							0x14,0xA7,0x85,0x7F,0x1B,0xCA,0x36,0x46, 0x36,0xE2,0xCC,0xBE,0xD9,0x3A,0xDF,0x4E, 
							0xC0,0xCA,0x20,0x50,0x5F,0xC6,0x13,0x94, 0xA2,0x73,0x72,0x23,0xC8,0x7C,0x57,0x26, 
							0xBB,0x46,0x89,0x47,0x6B,0x0C,0x6E,0x1D, 0xD4,0xD8,0xFE,0x22,0x17,0x96,0xA5,0x9E, 
							0x21,0x90,0x64,0xFE,0xF1,0x62,0xF9,0x6D, 0x8C,0xDF,0x94,0x8A,0x01,0xBA,0x77,0x50, 
							0x9F,0xEC,0x02,0xE8,0xBE,0x36,0x62,0xFA, 0x64,0x29,0x6E,0x01,0xEA,0x33,0xE1,0xDB, 
							0xF9,0x3F,0x1C,0x09,0x88,0x35,0xCA,0x38, 0x8D,0x24,0x37,0xDE,0xC3,0x3A,0xB7,0xAC, 
							0x89,0xD7,0x65,0xE3,0x37,0xBE,0x61,0xDD, 0xB3,0xA8,0xCB,0x08,0xCC,0xB2,0x41,0x48, 
							0xE3,0x3A,0xCB,0xB3,0xE3,0xD8,0x88,0x87, 0xBD,0x05,0xE0,0xA4,0xD5,0x2B,0x08,0x2B};

static
int
SC_CMVP_IntegrityTest(void)
{
	U8 *buffer = NULL;
	U8 modulename[MAX_PATH] = {0x00,};
	U8 filetail[68] = {0x00,};
	struct stat	st;
	int fd = -1, len;
	
	int retCode = 0;
	
	U8 signature[4096] = {0x00,};
	U32 signatureLength = 0;

	SC_PKEY_PublicKey  pubKey;
	SC_PKEY_Parameters params;
	SC_PKEY_SignParam  signParam;
	SC_BIGINT y;

	U8 a[256] = {0x00,};
	U8 b[256] = {0x00,};
	U8 c[256] = {0x00,};
	int aLength = 0;
	int bLength = 0;
	int cLength = 0;
	
	
	
	GetModuleFileNameA(g_crypto_hmodule, modulename, sizeof(modulename));

	// open file with read mode
	fd = _open(modulename, (_O_RDONLY | _O_BINARY), 0);
	if (fd < 0) { 
		retCode = -1; goto end; 
	}

	if (stat(modulename, &st) < 0) {
		retCode = -1; goto end;
	}

	// check whether file has hmac code or not
	if (st.st_size <= (4+64)) { retCode = -1; goto end; }

	if (_lseek(fd, -(4+64), SEEK_END) < 0) { 
		retCode = -1; goto end;
	}

	len = _read(fd, filetail, (4+64));
	if (len != 68) {
		retCode = -1; goto end;
	}

	// calc length
	signatureLength = filetail[0] * 0x1000000;
	signatureLength += filetail[1] * 0x10000;
	signatureLength += filetail[2] * 0x100;
	signatureLength += filetail[3];
	if(signatureLength != 64) {
		retCode = -1; goto end;
	}

	// read module
	if (_lseek(fd, 0, SEEK_SET) < 0) {
		retCode = -1; goto end;
	}

	if ((buffer = sc_calloc(st.st_size, sizeof(char))) == NULL) {
		retCode = -1; goto end;
	}

	len = _read(fd, buffer, st.st_size);
	if (len != st.st_size) { 
		retCode = -1; goto end; 
	}
	params.pkeyID = pubKey.pkeyID = SC_PKEY_ID_KCDSA;

	retCode = SC_KCDSA_CreateKeyObject((SC_KCDSA_Parameters **)&params.params);
	if(retCode < 0) goto end;

	SC_Bigint_New(&y);
	pubKey.pubKey = &y;
		
	getPublicKey1(b, &bLength);
	cLength = _mix(c, b, INTE_KCDSA_P, sizeof(INTE_KCDSA_P));
	aLength = SC_Codec(a, c, cLength);
	SC_BIGINT_CHK( SC_Bigint_Read_Binary( &((SC_KCDSA_Parameters *)params.params)->KCDSA_p, a, aLength ) );

	getPublicKey2(b, &bLength);
	cLength = _mix(c, b, INTE_KCDSA_Q, sizeof(INTE_KCDSA_Q));
	aLength = SC_Codec(a, c, cLength);
	SC_BIGINT_CHK( SC_Bigint_Read_Binary( &((SC_KCDSA_Parameters *)params.params)->KCDSA_q, a, aLength ) );

	getPublicKey3(b, &bLength);
	cLength = _mix(c, b, INTE_KCDSA_G, sizeof(INTE_KCDSA_G));
	aLength = SC_Codec(a, c, cLength);
	SC_BIGINT_CHK( SC_Bigint_Read_Binary( &((SC_KCDSA_Parameters *)params.params)->KCDSA_g, a, aLength ) );

	getPublicKey4(b, &bLength);
	cLength = _mix(c, b, INTE_KCDSA_Y, sizeof(INTE_KCDSA_Y));
	aLength = SC_Codec(a, c, cLength);
	SC_BIGINT_CHK( SC_Bigint_Read_Binary( &y, a, aLength ) );
	
	signParam.kcdsa.pkPubKey = &pubKey;

	retCode = SC_PKEY_Verify(filetail + 4, signatureLength, SC_PKEY_MSGID_MESSAGE, 
		                     buffer, len-68, SC_PKEY_SIGNID_KCDSA_SHA256, &pubKey, &params, &signParam);
	if(retCode < 0) goto end;

end:
	
	if(retCode != 0) {
		retCode = SCC_SELFTEST_ERROR_INTEGRITY;
	}

	if (buffer != NULL) sc_free(buffer);

	SC_Memzero(a, 0x00, sizeof(a));
	SC_Memzero(b, 0x00, sizeof(b));
	SC_Memzero(c, 0x00, sizeof(c));
	
	_close(fd);

	return retCode;

}

/**
 *
 *
 *
 */
static
int
SC_CMVP_AlgorithmTest(void)
{
	int	retCode = 0;

	// cryptographic algorithm test
	retCode  = SC_ARIA_SelfTest();
	if(retCode < 0) goto end;
	
	retCode = SC_Hash256_SelfTest();
	if(retCode < 0) goto end;
	
	retCode = SC_Hash512_SelfTest();
	if(retCode < 0) goto end;
	
	retCode = SC_HMAC256_SelfTest();
	if(retCode < 0) goto end;

	retCode = SC_HMAC512_SelfTest();
	if(retCode < 0) goto end;
 	
	retCode = SC_RSA_SelfTest();
	if(retCode < 0) goto end;
	
	retCode = SC_KCDSA_SelfTest();
	if(retCode < 0) goto end;

	// HASH_DRBG
	retCode = SC_DRBG_SelfTest();
	if(retCode < 0) goto end;

end:
	return retCode;
}



static
int
SC_RAND_SelfTest()
{
	U8		random[33];
	U32		randomLength = 32;
	int	retCode;

	retCode = SC_CMVP_RAND_Init();
	if (retCode != 0) goto end;
	
	retCode = SC_CMVP_RAND_GetRandom(random, randomLength);
	if (retCode != 0) goto end;

	retCode = 0;

end:
	return retCode;
}


/**
 *
 *
 *
 */
int
SC_CMVP_SelfTest(void)
{
	int retCode = 0, len = 0;
	SC_ENTROPY_CTX entropy_ctx_1;
	SC_ENTROPY_CTX entropy_ctx_2;

	// 자가시험 상태 진입
	retCode = SC_CMVP_MoveStatus(SCC_STATUS_SELFTEST);
	if (retCode != 0) goto end;

	retCode = SC_CMVP_AlgorithmTest();
	if (retCode != 0) goto end;

	retCode = SC_CMVP_IntegrityTest();
	if (retCode != 0) goto end;
	
	// 난수발생기 엔트로피 시험
	retCode = SC_Entropy_Accumulate(&entropy_ctx_1);
	if (retCode != 0) goto end;

	retCode = SC_Entropy_Accumulate(&entropy_ctx_2);
	if (retCode != 0) goto end;

	// 두 개의 엔트로피가 서로 같으면 실패
	// 1. 수집한 엔트로피의 길이가 다르면 실패
	if (entropy_ctx_1.dataLength != entropy_ctx_2.dataLength) {
		retCode = SCC_SELFTEST_ERROR_ENTROPY_COMPARE;
		goto end;
	}

	// 2. 엔트로피 비교 후, 같으면 실패
	len = entropy_ctx_1.dataLength;
	if(memcmp(entropy_ctx_1.data, entropy_ctx_2.data, len) == 0) {
		retCode = SCC_SELFTEST_ERROR_ENTROPY_COMPARE;
		goto end;
	}

end:

	// 엔트로피 제로화
	SC_Memzero(&entropy_ctx_1, 0x00, sizeof(SC_ENTROPY_CTX));
	SC_Memzero(&entropy_ctx_2, 0x00, sizeof(SC_ENTROPY_CTX));

	return retCode;
}

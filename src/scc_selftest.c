/* 
========================================
  scc_selftest.c
----------------------------------------
  Softcamp(c).
  2015.10.
========================================
*/

#define _CRT_SECURE_NO_DEPRECATE

#include <stdlib.h>
#include <string.h>
#ifdef _WIN32
#include <windows.h>
#endif

#include "scc_aria.h"
#include "scc_sha256.h"
#include "scc_sha512.h"
#include "scc_error.h"
#include "scc_hmac_sha.h"
#include "scc_cmvp.h"
#include "scc_drbg.h"
#include "scc_rsa.h"
#include "scc_kcdsa.h"
#include "scc_malloc.h"
#include "scc_pkey.h"
#include "scc_entropy.h"
#include "scc_util.h"

typedef struct {
	int		cipherID;
	U8		plain[64];
	U32		plainLength;
	U8		cipher[64];
	U32		cipherLength;
	U8		key[48];
	U32		keyLength;
	int		modeID;
	U8		iv[16];
	U32		ivLength;
	int		paddingID;
} SC_CIPHER_TV;

static const
SC_CIPHER_TV	tv_cipher[] = {
	{	SCC_CIPHER_ID_ARIA,
		{ 0xCB,0x92,0x56,0x74,0xC9,0xEE,0x80,0x78,0x78,0xF5,0x73,0xC5,0x5B,0x2C,0x70,0x2D,
		0x4E,0x0D,0xD7,0x17,0x6D,0x5A,0x35,0x74,0x33,0xB0,0x7D,0xF5,0xDF,0x5F,0x96,0x7B,
		0x1C,0x79,0x16,0xD0,0xE0,0x29,0x4E,0x94,0x95,0x46,0x86,0x7A,0x77,0x28,0x89,0xB4,
		0x3D,0xBB,0x65,0xAB,0xFB,0xD1,0x6C,0xF4,0x47,0xBD,0x7E,0x7F,0x9B,0x1D,0x8B,0x12 }, 64, //plain

		{ 0x69,0xD2,0x56,0xDF,0xA8,0x1A,0x97,0xBD,0x69,0xB5,0xBB,0x6B,0x29,0x1D,0x5F,0x0F,
		0xDF,0x5F,0x63,0xC0,0x83,0x0B,0xD7,0xB1,0x31,0x2D,0xBF,0x73,0xE1,0xE5,0x5D,0x0E,
		0x0C,0x8D,0xC4,0x8A,0xA9,0xBD,0x5F,0xC7,0xB5,0x61,0xA0,0x2B,0x90,0x64,0x1A,0xDE,
		0xD2,0xE1,0x61,0xB9,0xCE,0xF4,0x0B,0x1C,0x9C,0x43,0x69,0x6D,0xB2,0x32,0x98,0x44 }, 64, //cipher

		{ 0xC1,0x19,0x8A,0x7B,0xC9,0xAF,0x00,0xB3,0x92,0x3C,0xD7,0xED,0xE7,0x76,0xC5,0x98 }, 16, //key		
		SCC_CIPHER_MODE_CBC, 
		{ 0xCA,0x62,0x82,0x1A,0x5B,0xB1,0xCF,0xC1,0xFB,0x50,0xB7,0xFC,0xB0,0x3B,0x15,0xCB }, 16, //iv
		SCC_CIPHER_PADDING_NO
	},

	{	SCC_CIPHER_ID_ARIA,
		{ 0xA0,0x82,0x09,0x60,0x47,0xBB,0x16,0x56,0x50,0x1F,0xAB,0x8B,0x10,0xFE,0xF0,0x5C,
		0x05,0x32,0x63,0x1A,0xC4,0x46,0x6F,0x55,0x32,0xDE,0x41,0x5A,0xF7,0x52,0xD7,0xFA,
		0x30,0x9D,0x59,0x8D,0x64,0x76,0xAD,0x37,0xBA,0xBC,0x46,0x6A,0x69,0x17,0x3C,0xAC,
		0x6F,0xDD,0xA2,0x9B,0x86,0x32,0x14,0x2E,0x54,0x74,0x8F,0x3D,0xE2,0xD6,0x85,0x44 }, 64, //plain

		{ 0x91,0x02,0xA9,0xD3,0x4B,0x9A,0x8F,0xE6,0x9F,0xE4,0x51,0x57,0xC9,0x42,0xDA,0x68,
		0xCA,0xF6,0x54,0x51,0x90,0xEC,0x20,0x2E,0xAB,0x25,0x6C,0xD9,0x8B,0x99,0xA6,0x1C,
		0x72,0xC9,0x01,0xD6,0xBC,0x2B,0x26,0x78,0x42,0x00,0x84,0x0A,0xDD,0xA8,0xD9,0xB5,
		0xC6,0xC8,0x30,0xB6,0xAB,0xEA,0x71,0x84,0xB2,0x57,0x97,0x32,0xDB,0x35,0x23,0xD8 }, 64, //cipher

		{ 0x07,0x2C,0xF4,0x61,0x79,0x09,0x01,0x8F,0x37,0x32,0x98,0xD4,0x86,0x2B,0x3B,0x80,0x07,0x60,0xBA,0xF0,0x2E,0xC3,0x4A,0x57 }, 24, //key		
		SCC_CIPHER_MODE_CBC,
		{ 0xF5,0xB5,0xD7,0xBF,0xD2,0x2A,0x9B,0x4A,0xE6,0x08,0xF0,0xBE,0x77,0xD1,0x62,0x40 }, 16, //iv
		SCC_CIPHER_PADDING_NO
	},

	{	SCC_CIPHER_ID_ARIA,
		{ 0x30,0x9D,0x59,0x8D,0x64,0x76,0xAD,0x37,0xBA,0xBC,0x46,0x6A,0x69,0x17,0x3C,0xAC,
		0x6F,0xDD,0xA2,0x9B,0x86,0x32,0x14,0x2E,0x54,0x74,0x8F,0x3D,0xE2,0xD6,0x85,0x44,
		0x4F,0x4A,0x31,0x64,0xC6,0xA5,0x29,0xAA,0xAD,0xFD,0x32,0x94,0x1F,0x56,0x57,0xD1,
		0x9D,0x7E,0x3D,0x49,0x00,0x36,0xB1,0x5D,0xB2,0x92,0x83,0x70,0x1E,0xA3,0x97,0xA6 }, 64, //plain

		{ 0xFB,0xD3,0xC3,0x8B,0xF7,0x89,0xCC,0x31,0xB1,0x7F,0xC3,0x91,0xDC,0x04,0xC6,0xD7,
		0x33,0xBD,0xE0,0xEE,0x0C,0xD5,0x70,0xED,0x1B,0x1D,0xAD,0x49,0x6F,0x5C,0xA1,0x68,
		0xD7,0x03,0xC9,0x65,0xA7,0x90,0x30,0x2B,0x26,0xEB,0xF4,0x7A,0xAC,0xCC,0x03,0xE1,
		0x6A,0xE5,0xDB,0x23,0x10,0x8A,0xCD,0x70,0x39,0x4D,0x7A,0xC9,0xCD,0x62,0xD1,0x65 }, 64, //cipher

		{ 0xF5,0xB5,0xD7,0xBF,0xD2,0x2A,0x9B,0x4A,0xE6,0x08,0xF0,0xBE,0x77,0xD1,0x62,0x40,
		0xA0,0x82,0x09,0x60,0x47,0xBB,0x16,0x56,0x50,0x1F,0xAB,0x8B,0x10,0xFE,0xF0,0x5C }, 32, //key		
		SCC_CIPHER_MODE_CBC,
		{ 0x05,0x32,0x63,0x1A,0xC4,0x46,0x6F,0x55,0x32,0xDE,0x41,0x5A,0xF7,0x52,0xD7,0xFA }, 16, //iv
		SCC_CIPHER_PADDING_NO
	},

	{	SCC_CIPHER_ID_ARIA,
		{ 0x37,0x32,0x98,0xD4,0x86,0x2B,0x3B,0x80,0x07,0x60,0xBA,0xF0,0x2E,0xC3,0x4A,0x57,
		0xF5,0xB5,0xD7,0xBF,0xD2,0x2A,0x9B,0x4A,0xE6,0x08,0xF0,0xBE,0x77,0xD1,0x62,0x40,
		0xA0,0x82,0x09,0x60,0x47,0xBB,0x16,0x56,0x50,0x1F,0xAB,0x8B,0x10,0xFE,0xF0,0x5C,
		0x05,0x32,0x63,0x1A,0xC4,0x46,0x6F,0x55,0x32,0xDE,0x41,0x5A,0xF7,0x52,0xD7,0xFA }, 64, //plain

		{ 0x29,0x31,0x55,0xD2,0xE5,0x0B,0x81,0x39,0xF9,0xBC,0x63,0xE2,0xFA,0x26,0x99,0xDE,
		0xDE,0x18,0x93,0x68,0x81,0x7B,0x0A,0x4D,0xF6,0x03,0xE1,0xEE,0xF9,0x0E,0x1F,0xE8,
		0xA8,0x80,0x81,0x46,0xDC,0x24,0x43,0x3F,0xFF,0xFE,0x8C,0x3E,0x17,0x0A,0x6D,0xA2,
		0x47,0x55,0x62,0xA0,0x03,0x4E,0x48,0x67,0xA2,0x64,0xC0,0x9B,0x6C,0xA4,0xFD,0x6A }, 64, //cipher

		{ 0x8E,0xE5,0x5F,0xE2,0x39,0x80,0xF5,0x2B,0x77,0xB5,0xCA,0x90,0xDA,0x1D,0x22,0x17 }, 16, //key		
		SCC_CIPHER_MODE_CTR,
		{ 0xD9,0xA0,0x57,0x80,0xC8,0x96,0x70,0x86,0x07,0x2C,0xF4,0x61,0x79,0x09,0x01,0x8F }, 16, //iv
		SCC_CIPHER_PADDING_NO
	},

	{	SCC_CIPHER_ID_ARIA,
		{ 0xA0,0x82,0x09,0x60,0x47,0xBB,0x16,0x56,0x50,0x1F,0xAB,0x8B,0x10,0xFE,0xF0,0x5C,
		0x05,0x32,0x63,0x1A,0xC4,0x46,0x6F,0x55,0x32,0xDE,0x41,0x5A,0xF7,0x52,0xD7,0xFA,
		0x30,0x9D,0x59,0x8D,0x64,0x76,0xAD,0x37,0xBA,0xBC,0x46,0x6A,0x69,0x17,0x3C,0xAC,
		0x6F,0xDD,0xA2,0x9B,0x86,0x32,0x14,0x2E,0x54,0x74,0x8F,0x3D,0xE2,0xD6,0x85,0x44 }, 64, //plain

		{ 0x5A,0xFB,0xB1,0x2C,0x6E,0xE5,0xB8,0xE0,0x80,0xB6,0x77,0xA8,0xFE,0x10,0x3A,0x99,
		0x00,0x8E,0x30,0x23,0x7D,0x50,0x87,0xDA,0xC6,0x46,0x73,0x37,0x8B,0xF1,0xAB,0x26,
		0x2D,0xA8,0x0C,0xA8,0x9E,0x77,0xEE,0xFC,0x78,0x4F,0x03,0x0F,0xEB,0xC6,0x03,0x34,
		0xB9,0x9C,0x4F,0x59,0x55,0xC5,0x99,0x47,0xD4,0x7E,0xE8,0x06,0x43,0x5F,0xA1,0x6B }, 64, //cipher

		{ 0x07,0x2C,0xF4,0x61,0x79,0x09,0x01,0x8F,0x37,0x32,0x98,0xD4,0x86,0x2B,0x3B,0x80,0x07,0x60,0xBA,0xF0,0x2E,0xC3,0x4A,0x57 }, 24, //key		
		SCC_CIPHER_MODE_CTR,
		{ 0xF5,0xB5,0xD7,0xBF,0xD2,0x2A,0x9B,0x4A,0xE6,0x08,0xF0,0xBE,0x77,0xD1,0x62,0x40 }, 16, //iv
		SCC_CIPHER_PADDING_NO
	},

	{	SCC_CIPHER_ID_ARIA,
		{ 0x66,0x42,0x60,0x24,0xF3,0xE4,0xE9,0x7E,0x42,0x20,0xF4,0x61,0xCE,0x1C,0x5E,0x44,
		0x02,0x26,0x91,0xF7,0x41,0xA4,0xAB,0x34,0x29,0x49,0xDD,0x78,0x19,0x8F,0x10,0x10,
		0xF0,0x61,0xCF,0x77,0x18,0x17,0x61,0xDF,0xC4,0xA8,0x35,0x0E,0x75,0x1B,0x84,0x6B,
		0xC3,0x3F,0x31,0x59,0x5A,0x9C,0xF4,0xC3,0x43,0xA9,0xB7,0xF8,0x65,0x40,0x40,0xBA }, 64, //plain

		{ 0xB6,0x41,0x55,0x8F,0xEB,0x16,0x1E,0x4C,0x81,0xA0,0x85,0x6C,0xF0,0x07,0xA5,0x2A,
		0x19,0x91,0xED,0x3E,0xD6,0x30,0x8C,0xCA,0x5D,0x0F,0x58,0xCA,0xD2,0x8A,0xAC,0xA2,
		0x2B,0x86,0x4F,0xB5,0x85,0x4D,0xAC,0x6D,0xE5,0x39,0x1B,0x02,0x23,0x89,0x4E,0x4F,
		0x02,0x00,0xE8,0x1B,0x40,0x85,0x21,0x2B,0xC6,0xB1,0x98,0xED,0x70,0xB3,0xF8,0xC3 }, 64, //cipher

		{ 0x9C,0x5D,0xD7,0x66,0x36,0xFA,0x02,0x20,0x99,0x61,0x62,0x86,0x0F,0x43,0x2E,0x05,
		0x25,0x8B,0xFB,0xF1,0xAE,0x4C,0xDE,0x18,0x0B,0xF8,0xD0,0x9D,0xAA,0xD4,0x56,0x04 }, 32, //key		
		SCC_CIPHER_MODE_CTR,
		{ 0xCD,0xA8,0x61,0x89,0x8D,0xBB,0x72,0xB6,0x1E,0xFE,0x03,0x34,0x54,0x88,0x23,0xE2 }, 16, //iv
		SCC_CIPHER_PADDING_NO
	}
};

static
int
SC_ARIA_SelfTest()
{
	U8	cipher[64], plain[64];
	U32	cipherLength, plainLength;
	int	i, it;
	int	retCode;

	it = sizeof(tv_cipher)/sizeof(SC_CIPHER_TV);
	for (i=0; i<it; i++) {

		// ARIA 암호화
		retCode = SC_ARIA_Encrypt(cipher, &cipherLength, tv_cipher[i].plain, tv_cipher[i].plainLength,
									  tv_cipher[i].key, tv_cipher[i].keyLength, tv_cipher[i].iv,tv_cipher[i].ivLength, tv_cipher[i].modeID, tv_cipher[i].paddingID);
		if (retCode != 0) goto end;

		// 암호문과 벡터값을 비교
		if ((cipherLength != tv_cipher[i].cipherLength) ||
			(memcmp(cipher, tv_cipher[i].cipher, tv_cipher[i].cipherLength) != 0)) {
			retCode = SCC_SELFTEST_ERROR_ALGORITHM_ARIA_KAT; 
			goto end;
		}

		// ARIA 복호화
		retCode = SC_ARIA_Decrypt(plain, &plainLength, tv_cipher[i].cipher, tv_cipher[i].cipherLength,
									  tv_cipher[i].key, tv_cipher[i].keyLength, tv_cipher[i].iv,tv_cipher[i].ivLength, tv_cipher[i].modeID, tv_cipher[i].paddingID);
		if (retCode != 0) goto end;

		// 복호문과 평문 벡터값을 비교
		if ((plainLength != tv_cipher[i].plainLength) ||
			(memcmp(plain, tv_cipher[i].plain, tv_cipher[i].plainLength) != 0)) {
			retCode = SCC_SELFTEST_ERROR_ALGORITHM_ARIA_KAT; 
			goto end;
		}
	}

	retCode = 0;

end:
	// 파라미터 제로화
	SC_Memzero(cipher, 0x00, sizeof(cipher));
	SC_Memzero(plain, 0x00, sizeof(plain));
	return retCode;
}

/**
 *
 *
 *
 */

typedef struct {
	U8		input[200];
	U32		inputLength;
	U8		hash[64];
	U32		hashLength;
} SC_HASH256_TV;

static const
SC_HASH256_TV	tv_hash_256[] = {
	// SHA256
	{	{ 0xD3,0x69,0x67,0x60,0x07,0x0A,0x0D,0x14,0x3C,0xBC,0x3E,0xE3,0xE7,0xB4,0xB2,0xB8,
		0x1A,0x46,0xB9,0xAF,0x4E,0x9D,0x21,0x70,0x5F,0xAE,0x5A,0xBC,0xD8,0x6E,0xD8,0x45,
		0x71,0x43,0xB9,0xC3,0xD6,0xB9,0xA8,0x44,0xAA,0x77,0x01,0xC3,0xCC,0x71,0x35,0xFD,
		0xD9,0x5F,0x71,0x80,0xF2,0x6D,0x7A,0x05,0xBF,0x34,0xDC,0xFF,0xB3,0xE9,0x43,0x74,
		0x92,0xD4,0x29,0x0C,0x31,0x04,0xB1,0x68,0x7E,0x42,0xD3,0xB4,0xBF,0x43,0xBA,0x80,
		0x1F,0x22,0x6A,0xCB,0x66,0x0D,0xA6,0x61,0x08,0x3E,0x11,0x68,0x61,0x2C,0x93,0x35,
		0x3F,0x03,0xFE,0x64,0xA1,0x52,0xF2,0x27,0xBE,0x04,0xFE,0xDE,0x49,0x92,0x07,0xE8,
		0xF4,0x77,0xEE,0xB9,0x33,0xE3,0x6D,0x2D,0x42,0xB3,0x42,0x1C,0x69,0xA1,0x90,0x2F,
		0x7F,0xB8,0x82,0xF2,0xAD,0x0C,0x31,0x2A,0x74,0xA7,0xC8,0x68,0xF1,0xC6,0xE6,0xDE,
		0x60,0x46,0x43,0x72,0xE0,0x59,0x97,0x11,0x75,0x7D,0xB7,0x46,0x53,0xAF,0x01,0x0B,
		0x5A,0xDB,0xFB}, 163,
		{ 0x07,0x60,0x78,0xB6,0x48,0x2A,0xDF,0x70,0x33,0xFA,0x16,0x5D,0x5D,0x40,0xF2,0x7B,
		0x78,0x7C,0xFD,0xD7,0x01,0x24,0xD3,0x92,0xEF,0xEC,0x95,0x1D,0x3E,0x56,0xF8,0x2E }, 32
	}
};

static
int
SC_Hash256_SelfTest()
{
	U8		hash[64];
	U32		hashLength;
	int		i, it;
	int		retCode;

	it = sizeof(tv_hash_256)/sizeof(SC_HASH256_TV);
	for (i=0; i<it; i++) {
		// SHA256 해쉬 생성
		retCode = SC_SHA256_Digest(hash, &hashLength, tv_hash_256[i].input, tv_hash_256[i].inputLength);
		if (retCode != 0) goto end;

		// 출력값을 벡터값과 비교
		if ((hashLength != tv_hash_256[i].hashLength) ||
			(memcmp(hash, tv_hash_256[i].hash, tv_hash_256[i].hashLength) != 0)) {
			retCode = SCC_SELFTEST_ERROR_ALGORITHM_HASH_SHA256_KAT; 
			goto end;
		}
	}

	retCode = 0;

end:
	return retCode;
}

/**
 *
 *
 *
 */


typedef struct {
	U8		input[300];
	U32		inputLength;
	U8		hash[64];
	U32		hashLength;
} SC_HASH512_TV;

static const
SC_HASH512_TV	tv_hash_512[] = {
	// SHA512
	{	{ 0xED,0x4C,0xA8,0x5B,0x5C,0xBF,0x51,0x99,0x39,0x9C,0x9F,0x43,0xBE,0xC7,0x33,0x88,
		0x2A,0x10,0xEE,0xD5,0x0A,0x64,0x58,0xA5,0xB7,0x44,0x3E,0x99,0x20,0x77,0xA0,0xCB,
		0xC9,0xFC,0xCA,0x60,0x14,0x43,0xC0,0x5C,0xC0,0x9D,0xDF,0xBA,0xAF,0xF0,0xC2,0xBD,
		0xEC,0xAF,0x63,0x81,0xEC,0x09,0x82,0xD5,0x14,0x61,0x4B,0x4D,0x7C,0xFF,0x33,0x92,
		0xF3,0x05,0x23,0xFD,0x43,0xA4,0xD8,0x64,0xB6,0x8F,0x8A,0x34,0xD8,0xB0,0xCB,0xC0,
		0x7F,0x1B,0xB3,0xD9,0x09,0x40,0x3A,0x9F,0xE5,0x64,0xE5,0x96,0x55,0x52,0xA5,0xFD,
		0x71,0x4D,0xFC,0x5B,0x70,0x4A,0x61,0x5A,0x23,0x5C,0xE6,0xD8,0xC2,0x70,0x18,0x3C,
		0xEB,0x3A,0x26,0x06,0xE8,0x6F,0x46,0xAB,0x31,0x35,0x55,0x9F,0x31,0xD8,0xBD,0xB3,
		0x4D,0xBE,0x9C,0xA1,0x23,0x9D,0x23,0xE5,0x0F,0xEB,0x3C,0xCF,0xF4,0x96,0x6F,0xD7,
		0x39,0xF6,0x06,0x30,0x11,0x00,0x6F,0xA0,0x00,0xBC,0xE3,0x8E,0x9B,0xF9,0x45,0x5D,
		0x8F,0x3F,0x4D,0xF8,0xE4,0x05,0xE5,0xAE,0x83,0x24,0xD3,0x41,0xF6,0x8C,0x99,0x39,
		0x70,0x35,0x99,0x7E,0x0D,0x59,0x7D,0x26,0x5A,0xE1,0xD6,0x8C,0x18,0x1D,0x03,0xA2,
		0x3D,0xB7,0x55,0x88,0x3C,0xEA,0x71,0x5D,0x86,0xEF,0xF5,0x55,0x51,0xB8,0x5E,0x0B,
		0x98,0xE1,0x29,0x19,0x63,0xE4,0x38,0xE7,0x48,0x8C,0x78,0xC0,0x32,0xAC,0xC1,0x2B,
		0x61,0x10,0xFD }, 227,
		{ 0x6C,0x9F,0x50,0x23,0xFC,0x7D,0xF3,0x79,0xFC,0x23,0xF3,0x24,0x2F,0x18,0xD3,0xAC,
		0x9B,0x34,0xF5,0x9A,0xED,0xBF,0xEE,0x00,0x70,0xAA,0x42,0xEB,0x62,0xE0,0x2A,0x1E,
		0x0F,0xC3,0xE8,0xF2,0xA2,0x69,0xFF,0xAD,0x8B,0x2E,0x33,0x8A,0x86,0x5A,0x2F,0x1F,
		0x4A,0x39,0x8F,0xFE,0x1C,0xEA,0xE2,0xF6,0x3A,0x2D,0x0E,0x03,0xBD,0xF8,0x3D,0x08 }, 64
	}
};

static
int
SC_Hash512_SelfTest()
{
	U8		hash[64];
	U32		hashLength;
	int			i, it;
	int		retCode;

	it = sizeof(tv_hash_512)/sizeof(SC_HASH512_TV);
	for (i=0; i<it; i++) {
		// SHA512 해쉬 생성
		retCode = SC_SHA512_Digest(hash, &hashLength, tv_hash_512[i].input, tv_hash_512[i].inputLength);
		if (retCode != 0) goto end;

		// 출력값을 벡터값과 비교
		if ((hashLength != tv_hash_512[i].hashLength) ||
			(memcmp(hash, tv_hash_512[i].hash, tv_hash_512[i].hashLength) != 0)) {
			retCode = SCC_SELFTEST_ERROR_ALGORITHM_HASH_SHA512_KAT; 
			goto end;
		}
	}

	retCode = 0;

end:
	return retCode;
}


/**
 *
 *
 *
 */

typedef struct {
	U8		input[128];
	U32		inputLength;
	U8		key[32];
	U32		keyLength;
	U8		mac[32];
	U32		macLength;
} SC_HMAC_TV_256;

static const
SC_HMAC_TV_256	tv_mac_256[] = {
	// HMAC
	{	{ 0x54,0x8A,0x45,0x72,0x80,0x85,0x1E,0xCA,0x0F,0x54,0x76,0xAF,0xDA,0xC1,0x02,0xCF,
		0x6C,0x7D,0xBE,0x09,0xB3,0x08,0x3D,0x74,0xFB,0xD0,0x3D,0xA3,0x1E,0x9D,0x7F,0x27,
		0xF4,0x2C,0xD6,0x56,0x11,0x1A,0x7D,0x4B,0xB0,0x05,0xAD,0x2E,0xEA,0xED,0x6F,0xB6,
		0x2C,0xE0,0xB0,0xEB,0xE7,0xD6,0x93,0x31,0x89,0xDA,0x0B,0x82,0xAD,0x6A,0xA8,0xFB,
		0x8E,0x21,0xB1,0x9A,0xC2,0x93,0x74,0x46,0x25,0x79,0xDA,0x0F,0x13,0x0E,0x3E,0xB8,
		0xDA,0xB8,0x7F,0x72,0x6E,0xEB,0x54,0xEB,0x5F,0x4A,0xE0,0x87,0x09,0x10,0x87,0xED,
		0x0B,0xAF,0xFF,0xC6,0xFA,0xB7,0xAA,0xC1,0x56,0xF8,0x23,0xDB,0xBC,0xEB,0x17,0xDD,
		0x5E,0x4E,0x56,0x26,0xB1,0x0F,0x29,0xAA,0x65,0x6B,0xE7,0x3B,0x9A,0x57,0xC3,0x08 }, 128,
		{ 0xC6,0xF1,0xD6,0x67,0xA5,0x0A,0xAE,0xBA,0x5A,0x20,0x0A,0x0A,0x7C,0xC2,0x4F,0xFB,
		0xB2,0x49,0x84,0x42,0x6A,0xB8,0xAB,0xAC,0xCE,0xE7,0x51,0x62,0xF3,0xE1,0x64,0x6B}, 32,
	    { 0x96,0xC3,0x7F,0x36,0xCA,0x0D,0xEA,0x3B,0x2B,0x3E,0x60,0xF1,0xF6,0xCD,0xF7,0x9C}, 16
	}
};

static
int
SC_HMAC256_SelfTest()
{
	U8		mac[32];
	U32		macLength;
	int			i, it;
	int	retCode;

	it = sizeof(tv_mac_256)/sizeof(SC_HMAC_TV_256);
	for (i=0; i<it; i++) {
		retCode = SC_HMAC_SHA256(mac, &macLength, tv_mac_256[i].key, tv_mac_256[i].keyLength, tv_mac_256[i].input, tv_mac_256[i].inputLength);
		if (retCode != 0) goto end;
		
		if (memcmp(mac, tv_mac_256[i].mac, tv_mac_256[i].macLength) != 0) {
			retCode = SCC_SELFTEST_ERROR_ALGORITHM_HMAC_SHA256_KAT; 
			goto end;
		}
	}

	retCode = 0;

end:
	// mac 생성값 제로화
	SC_Memzero(mac, 0x00, sizeof(mac));

	return retCode;
}

typedef struct {
	U8		input[128];
	U32		inputLength;
	U8		key[128];
	U32		keyLength;
	U8		mac[64];
	U32		macLength;
} SC_HMAC_TV_512;

static const
SC_HMAC_TV_512	tv_mac_512[] = {
	// HMAC
	{	{ 0xF4,0x2C,0xD6,0x56,0x11,0x1A,0x7D,0x4B,0xB0,0x05,0xAD,0x2E,0xEA,0xED,0x6F,0xB6,
		0x2C,0xE0,0xB0,0xEB,0xE7,0xD6,0x93,0x31,0x89,0xDA,0x0B,0x82,0xAD,0x6A,0xA8,0xFB,
		0x8E,0x21,0xB1,0x9A,0xC2,0x93,0x74,0x46,0x25,0x79,0xDA,0x0F,0x13,0x0E,0x3E,0xB8,
		0xDA,0xB8,0x7F,0x72,0x6E,0xEB,0x54,0xEB,0x5F,0x4A,0xE0,0x87,0x09,0x10,0x87,0xED,
		0x0B,0xAF,0xFF,0xC6,0xFA,0xB7,0xAA,0xC1,0x56,0xF8,0x23,0xDB,0xBC,0xEB,0x17,0xDD,
		0x5E,0x4E,0x56,0x26,0xB1,0x0F,0x29,0xAA,0x65,0x6B,0xE7,0x3B,0x9A,0x57,0xC3,0x08,
		0x51,0x1F,0xE8,0x63,0x20,0x4D,0xC8,0xC7,0x2B,0xCC,0xB0,0x19,0x4F,0x4D,0xA0,0x2E,
		0xA0,0xEA,0x5B,0x8E,0x16,0x09,0xBA,0x77,0x83,0x84,0x45,0x25,0xC8,0x07,0x04,0x51 }, 128,
		{ 0xC6,0xF1,0xD6,0x67,0xA5,0x0A,0xAE,0xBA,0x5A,0x20,0x0A,0x0A,0x7C,0xC2,0x4F,0xFB,
		0xB2,0x49,0x84,0x42,0x6A,0xB8,0xAB,0xAC,0xCE,0xE7,0x51,0x62,0xF3,0xE1,0x64,0x6B,
		0x54,0x8A,0x45,0x72,0x80,0x85,0x1E,0xCA,0x0F,0x54,0x76,0xAF,0xDA,0xC1,0x02,0xCF,
		0x6C,0x7D,0xBE,0x09,0xB3,0x08,0x3D,0x74,0xFB,0xD0,0x3D,0xA3,0x1E,0x9D,0x7F,0x27 }, 64,
	    { 0xF6,0x39,0xD2,0xDC,0xB7,0x60,0xD4,0xE5,0xD0,0x53,0xFB,0xCA,0x3E,0x7D,0x2A,0x33,
		0xD9,0x37,0x3B,0xFA,0x45,0xFC,0xE6,0xCE,0xFC,0xFF,0x77,0xB3,0x51,0x75,0x8C,0x09 }, 32
	}
};

static
int
SC_HMAC512_SelfTest()
{
	U8		mac[64];
	U32		macLength;
	int			i, it;
	int	retCode;

	it = sizeof(tv_mac_512)/sizeof(SC_HMAC_TV_512);
	for (i=0; i<it; i++) {
		retCode = SC_HMAC_SHA512(mac, &macLength, tv_mac_512[i].key, tv_mac_512[i].keyLength, tv_mac_512[i].input, tv_mac_512[i].inputLength);
		if (retCode != 0) goto end;
		
		if (memcmp(mac, tv_mac_512[i].mac, tv_mac_512[i].macLength) != 0) {
			retCode = SCC_SELFTEST_ERROR_ALGORITHM_HMAC_SHA512_KAT; 
			goto end;
		}
	}

	retCode = 0;

end:
	// mac 생성값 제로화
	SC_Memzero(mac, 0x00, sizeof(mac));

	return retCode;
}


#define KEY_LEN 256
#define PT_LEN  28

#define RSA_N   "B59B261C310BB787FD7D546D2FFBDC733F40101ECA0D0"\
				"D00F2C6AB6078AFF4D19523D20AB944805269521986DA"\
				"F968E9E663B79216DF5C6AEDC2EAB1F95BA042CA467AB"\
				"EEFC41D72EB3DA5F9CE4499B77C541B721652D8E41F8D"\
				"670EA3E83BEBFE20986D6AF54729EF8A72849382F4B06"\
				"547B77656D289B33517242F3A00693029CA0C5F00AB9D"\
				"856E4B6CE82B1A226BE1C230FDFA6492830ABDE8CF8B5"\
				"728406A44D6952D03A0895D11CE8F6C2F941B04A3DBB6"\
				"3ED95B975DFADEA46CE97E58C1BB865039FEC58AFB548"\
				"25299922FCA052CD29E7A7F8FB2AB42A758FC986FCC0C"\
				"E0BC603485D7E0A73F7297B21631A6684086F0E01B2DF"\
				"4551E2065DEAFC037"


#define RSA_E   "10001"

#define RSA_D   "A0FF6E85C7A54F8BABDA9422484BCC600F4EC7FBC3BC5"\
				"62EE50BE39A9EE3BEF29E79271882AE8BE483A2592708"\
				"B1DBA4A0AEFE6AF1040B76705A409E8F25FFA9B6914CF"\
				"840AF683C1CF8865033E0F535896F36F5A97CC0F35C55"\
				"8B6B9B3BA303D0432D5EB357C743122D76E0B9B57B1F7"\
				"66A61E6F389AAB1C8FB3F04EF32B60C905C5E07AD2B81"\
				"F8D9C2839372D75E9A16D645760A7C75A9EA2FD9A61C6"\
				"F4F760DEDABEEE1CF1532F5E7D7AFEC5C016704530659"\
				"9C266A48C0C0342BBCD852B78728B3CBA520AA48EE60F"\
				"5EDB37787BAB62D4259787376089E4FE6D6B024E3A842"\
				"C6F8F0F6D01947B5128BACC1CA87F5E919A57D360DAE9"\
				"CDEF443693D065DC1"

#define RSA_P   "C242D28C7E55DC613CD8A43E37D8A4756DF8C1EEAAF9F"\
				"C2ACE2220E67AB2551F2EA97449DE7C6D3807B8CF7CD2"\
				"F4C280EF64DF75829D5A1D69AE4B240B9EB535868E8F5"\
				"01491D2E343F594A0354F75F30226477486C5498413D5"\
				"3EE2E6ADD223321360871706E0FC3A15268666B24F0CF"\
				"99B6A36A43A0EDB2894E5FC0392899F"

#define RSA_Q   "EF52B60AA5C8322AE44A34A8EF592C63869745BA72760"\
				"66D8734DA5658DD2BEF624263626C3C1F8D2362FB8C79"\
				"46BE3388CD8155B724067C48F6E162BB0E0D7835A8776"\
				"0C2DDCD4D1AB6A0C9C6099B8873230EE5A94B47A98157"\
				"5AB85BFA12DBFDB862F38027A219AD9BF03ED91D3CBF8"\
				"845FAD70D6CE211F0DF03E4B763F269"


// for encrypt
#define RSA_PT_ENC  "\x21\xB9\x61\xC6\xEE\xA0\xFE\x2F\x49\xCD\xCC\xA8\x98\x97\x9E\xAF\xF2\x89\xE1\x4C\xD9\xD0\x7B\x0B\x6B\x45\xC6\xAF"
#define RSA_CT_ENC	"\x61\x0A\x01\x20\x0E\xD3\x2B\xFA\xAF\xA7\x6F\xA5\xA3\x01\xA4\xA5\xB0\x6A\x60\xA2\x8A\x1F\x5A\xE1\xD2\x47\x01\xE8\x4E\x81\x03\x4C\xC9\xDE\xCB\xDB\x55\xEB\x57\x8E\x88\xF0\x5A\x85\xB2\xED\x40\x52\xD1\x62\x74\xE8\xCD\x60\xA2\xDE\xCD\xE5\xE2\x79\x05\xDA\x3F\x85\x44\xF3\x70\x13\x62\x3D\x2C\x99\xC4\x3F\x6B\x14\xA0\xF8\xF2\x01\x09\x72\xED\xFA\xD8\x8C\xEF\x46\xB5\x11\xC0\xA1\x2E\x8F\xBB\x1A\x83\x4D\x2D\xCD\xCB\x66\xC2\x8C\xC0\xBB\x77\x99\xE0\x57\xB1\x25\xCE\x72\x47\x16\x55\xC9\x0E\x64\xC7\x06\x94\x73\x12\x84\xDC\x5D\xB8\x71\x39\xEA\x94\x47\xFB\x8D\xE1\xB1\x0D\x3B\x8C\x89\xE3\xE6\x78\x54\xBD\x10\xBE\x78\x01\x6C\x5B\x40\xDE\x3A\xBD\x52\xA1\x73\x64\x3B\xAE\xEC\xCD\x86\x30\xE3\x37\x6E\x84\x40\x0D\x82\x0E\xF4\xAF\xE2\xBB\x57\x1E\x79\x54\x40\xC2\xF5\x3D\x55\x0B\xBD\x9A\x3E\xF5\xA2\xF6\x31\xC6\xF6\x8B\xA1\x84\x31\x97\xCD\x0A\x60\x97\x96\xA2\xA6\x16\xA3\x2E\x27\xDD\x18\x89\x1E\x69\xC6\xFD\x23\xC4\xAF\x97\xDD\x54\xC9\xF4\x69\x76\x6E\xEB\x6D\x1B\xA2\x38\xAB\x49\xC3\x33\x62\xDC\x52\x0F\x15\x7B\x11\xD8\x63\x1A\x87\xDF\x9D\x50\x25"

// for decrypt
#define RSA_PT_DEC "\x1E\x0C\xC7\xB7\xE6\xC4\x37\x43\xCD\x11\x5B\x7D\xD1\xF9\xA4\x13\x76\xCF\xF4\x46\xA6\x3B\xA9\x80\x29\x6B\x23\x56"
#define RSA_CT_DEC "\x76\xF4\x39\x85\x6D\x00\xBC\x4D\x85\x30\xA3\xFB\x21\x8B\xC3\xCC\x45\xF3\x91\x60\xD5\xB8\xFB\x89\x2A\x3D\x3B\x51\x0F\x24\x8D\xF1\x75\x71\xAB\x81\x85\xD9\x14\x30\x75\xDE\x42\x54\x2C\x61\x22\x61\xAA\xD3\x85\x46\x51\x16\x47\x4C\xB7\xA9\xA6\x47\xB2\x62\x57\xEE\xE5\x6C\x1D\x02\x18\x63\x9F\xB3\xFA\x28\x89\xB7\xAC\x0E\xF9\xC9\xA8\xB7\xD6\x8B\x4B\xB4\x11\x91\x5D\xF4\xAC\xB0\x4F\xB5\x10\xFD\x97\xB8\x57\x18\xA1\x87\xD8\x8C\xD6\xB5\xE5\x64\x4D\x34\xC9\xBF\xBC\x16\x33\x6F\xC2\x39\xB5\x75\x91\xFE\x53\xEC\x2F\xCE\xC4\x6E\xE9\xC2\xD6\x43\x15\xDE\xBB\xFE\x02\xCE\x1F\x91\x6D\x94\x18\x78\x98\x4B\x10\xDB\x82\xFE\x4E\x5E\xD9\xCF\x16\x81\x96\x14\x58\xBC\x5A\x28\xB0\xE1\x5E\x64\xB4\xB0\xC0\x22\xEA\xCB\x9F\xA5\xC4\x07\xEA\x3D\xE9\xD7\x26\xBA\x30\x82\x4D\xD3\x79\xEF\xD3\xA1\xE7\xD6\x45\xBF\x47\x2F\xC2\xA4\xB0\xDC\xFD\x3D\x44\xCA\x5E\xF2\x3A\x6A\xE6\x5E\xB1\x27\x8B\x18\xA8\x10\xB7\x7C\x5F\xA2\x99\x76\x5F\x34\x45\xD1\xA1\x26\xC7\xB9\x40\x9C\xC1\x7E\x03\xFD\xB6\x68\x71\x57\x4B\xFE\x08\x76\x8A\x04\xDD\x78\xE5\x8D\x0A\x64\xDF\x31\x9F\xDB"


static
int
SC_RSA_SelfTest()
{
	int retCode = 0;
	U32 length = 0;

	SC_RSA_PrivateKey *privKey = NULL;
	SC_RSA_PublicKey *pubKey = NULL;

	U8 rsa_plaintext[PT_LEN];
	U8 rsa_decrypted[PT_LEN];
	U8 rsa_ciphertext[KEY_LEN];

	// 키쌍 구조체 생성 / 설정
	privKey = SC_RSA_PrivateKey_New();
	if (privKey == NULL) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_RSA_KAT;
		goto end;
	}
	pubKey  = SC_RSA_PublicKey_New();
	if (pubKey == NULL) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_RSA_KAT;
		goto end;
	}

	SC_BIGINT_CHK( SC_Bigint_Read_String( privKey->n ,    16, RSA_N  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( privKey->e ,    16, RSA_E  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( privKey->d ,    16, RSA_D  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( privKey->p ,    16, RSA_P  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( privKey->q ,    16, RSA_Q  ) );
	
	SC_BIGINT_CHK( SC_Bigint_Read_String( pubKey->n , 16, RSA_N  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( pubKey->e , 16, RSA_E  ) );

	
	retCode = SC_RSA_Check_Privkey(privKey);
	if(retCode < 0) goto end;

	retCode = SC_RSA_Check_Pubkey(pubKey);
	if(retCode < 0) goto end;

	memcpy(rsa_plaintext, RSA_PT_ENC, PT_LEN );

	retCode = SC_RSA_Pkcs1_Encrypt(pubKey, SC_RSA_PKCS_V21, PT_LEN, rsa_plaintext, rsa_ciphertext);
	if(retCode < 0) goto end;

	if(memcmp(rsa_ciphertext, RSA_CT_ENC, KEY_LEN) != 0) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_RSA_KAT;
		goto end;
	}
	
	retCode = SC_RSA_Pkcs1_Decrypt(privKey, SC_RSA_PKCS_V21, &length, RSA_CT_DEC, rsa_decrypted, PT_LEN);
	if(retCode < 0) goto end;

	if(length != PT_LEN || memcmp(RSA_PT_DEC, rsa_decrypted, PT_LEN) != 0) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_RSA_KAT;
		goto end;
	}
	
 	retCode = 0;

end:

	// 키쌍 구조체 제거 및 제로화
	if(pubKey != NULL) {
		SC_RSA_PublicKey_Free(pubKey);
	}
	if(privKey != NULL) {
		SC_RSA_PrivateKey_Free(privKey);
	}

	return retCode;
}

#define KCDSA_P		"d06eb9f275b3ac7f2970b578ad1c3173" \
					"2a0126844776f95cf07b4194c6def6f4" \
					"16a66751458b0667cdbc44af3f6b5877" \
					"0e674a861c8febf4eea0e50450ec5272" \
					"26b8470717ee768cf39cfd32bc2540d2" \
					"924e0968e64d47ee4cf0ab6cd192284b" \
					"826c75082e18840b67bc4cb1f1708173" \
					"f08825ba4f6e5fb86a357f02c06f8283" \
					"f3cd58a1ed4d3062f4a5c0d2f26e54c0" \
					"fa511b5ed5cfd27019d4a90dda7aca50" \
					"561397abeede9cff45ec6cf3e22dac5c" \
					"af454b7b9b3b5ffe16128197768114c9" \
					"cd4be4e9ecdc431a0cc0ed544fd4da1c" \
					"9e98a2c3cb4297fe1d1387d81c51d492" \
					"5ede6a8bbaf660ef675549b4aea5267f" \
					"b5f778d5308dd69175de580ec316c4ef" 

#define KCDSA_Q		"cfefed9c75b5610fdb100d91c4cb8187" \
					"a007791733128ff143ffedf97f6ffd65" 

#define KCDSA_G		"023fec34dfa5e5ce369dd782b07034af"\
					"037ac18728d432045739b9861b0df1dc"\
					"aeeb5c9ed3e025d83adcdae0419c158b"\
					"09ee35ff84ab9caa9ed4e535f982fb99"\
					"e30d319537c05780a2cf31cf6bb226c6"\
					"6b7b3ed76b65dc658b216b867f186d98"\
					"0d30d1a95285a081c5aba363939660a5"\
					"7596c6212207e4e358b729bc079778b4"\
					"f385824c0862cdce08aeb2c658c18559"\
					"d3ed865cd6bed194da447fd41789c74d"\
					"352ed26b56c2d128f1154f733fe71f10"\
					"bf676c9f7e4268c053d13152997a2d9b"\
					"fb73fccb0dcea4c132f68f282a6db325"\
					"cc467fb7f1fe2da5f80fd32cae781a75"\
					"74845a3d457120543987b348d5d75b1b"\
					"954cba473f83951a8c1be717b953206c" 


#define KCDSA_X		"21e2cf868d004318aca87261476dfc67" \
					"c198336482fe1dcb3cbb5ba0f081158a" 

#define KCDSA_Y		"44ce4c95da1ff8bfbc6b7277ccc6694e" \
					"1b1e6dfacf617533354da0cf6966e156" \
					"2124003db09e33309a24f87c467917ae" \
					"dfeb911fd5344422063452757c40f0a0" \
					"bb45acc8e462c5ac4d8dd0f92fcc80f3" \
					"3e4160f598682bf571163c43bd703c2c" \
					"1827db2e2336511d84520afa97dc4962" \
					"40ea4a82ca2ffc646363f822d037c813" \
					"8f3458a3e41bd3a023b63cc113b33ecb" \
					"3fcccc5cbed325e7ec1f07e203e9aa8e" \
					"451c96fbdec927d6ee741540a90673b4" \
					"f2feac07b6f4eda08db28fdfaed8634e" \
					"7ff40582ae33d8dbf377a7619ad1c006" \
					"686337792943e6cd016d5534e4122bca" \
					"18d1207579ea4c90610a1496b63c23dc" \
					"996b686efeb34c361f9afdcf7e8fbf9a"

static
U8 KCDSA_M[] = { 0x54,0x68,0x69,0x73,0x20,0x69,0x73,0x20, 0x61,0x20,0x74,0x65,0x73,0x74,0x20,0x6d,
				0x65,0x73,0x73,0x61,0x67,0x65,0x20,0x66, 0x6f,0x72,0x20,0x4b,0x43,0x44,0x53,0x41,
				0x20,0x75,0x73,0x61,0x67,0x65,0x21 };

static
U8 KCDSA_RS[] = { 0x59,0x49,0x00,0x77,0xf9,0x8c,0x21,0x78, 0x85,0x09,0xcb,0x47,0x8c,0xcd,0xe7,0x7a,
				0x4f,0xb5,0x41,0x4e,0x13,0xcf,0x92,0x81, 0xcb,0x80,0x97,0x5b,0x33,0x70,0xd9,0x7d,
				0x18,0x5f,0x21,0xb5,0xdb,0xf4,0x25,0x5b, 0x95,0x4a,0x4d,0x62,0xcf,0x36,0x3c,0x32,
				0x73,0x21,0x11,0x47,0xcb,0xa0,0x54,0xe8, 0x3a,0x87,0xda,0x2d,0xd7,0xe0,0x74,0x1d };

static
int
SC_KCDSA_SelfTest()
{
	int retCode = 0;

	U8 signature[4096] = {0x00,};
	U32 signatureLength = 0;
		
	SC_PKEY_PrivateKey privKey;
	SC_PKEY_PublicKey  pubKey;
	SC_PKEY_Parameters params;
	SC_PKEY_SignParam  signParam;
	SC_BIGINT x;
	SC_BIGINT y;
	
	params.pkeyID = privKey.pkeyID = pubKey.pkeyID = SC_PKEY_ID_KCDSA;
	
	// KCDSA 파라미터 생성 / 설정
	retCode = SC_KCDSA_CreateKeyObject((SC_KCDSA_Parameters **)&params.params);
	if(retCode < 0) goto end;
	
	SC_Bigint_New(&x);
	privKey.privKey = &x;

	SC_Bigint_New(&y);
	pubKey.pubKey = &y;

	SC_BIGINT_CHK( SC_Bigint_Read_String( &((SC_KCDSA_Parameters *)params.params)->KCDSA_p , 16, KCDSA_P  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( &((SC_KCDSA_Parameters *)params.params)->KCDSA_q , 16, KCDSA_Q  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( &((SC_KCDSA_Parameters *)params.params)->KCDSA_g , 16, KCDSA_G  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( &x , 16, KCDSA_X  ) );
	SC_BIGINT_CHK( SC_Bigint_Read_String( &y , 16, KCDSA_Y  ) );
	signParam.kcdsa.pkPubKey = &pubKey;

	// 전자서명 생성
	retCode = SC_PKEY_Sign(signature, &signatureLength, SC_PKEY_MSGID_MESSAGE, KCDSA_M, sizeof(KCDSA_M), SC_PKEY_SIGNID_KCDSA_SHA256, &privKey, &params, &signParam);
	if(retCode < 0) goto end;

	// 생성된 서명문을 벡터값과 비교
	if(memcmp(signature, KCDSA_RS, signatureLength) != 0) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_KCDSA_KAT;
		goto end;
	}

	// 서명 검증
	retCode = SC_PKEY_Verify(KCDSA_RS, sizeof(KCDSA_RS), SC_PKEY_MSGID_MESSAGE, KCDSA_M, sizeof(KCDSA_M), SC_PKEY_SIGNID_KCDSA_SHA256, &pubKey, &params, &signParam);
	if(retCode < 0) goto end;

end:
	// 파라미터 제거 및 제로화
	SC_KCDSA_DestroyKeyObject((SC_KCDSA_Parameters **)&params.params);
	
	return retCode;
}



//
// HASH_DRBG 자가시험 코드
//

//// 초기화용 엔트로피 테스트 벡터
U8 _entropy1[32] = {
	0x71,0x45,0x91,0x07,0x82,0xAC,0xCB,0x48,0x30,0x8A,0xBB,0x1C,0x0A,0x41,0x07,0x22,0x7B,0x9F,0x1A,0xA8,0xF2,0x6A,0x6C,0xD5,0x3F,0x3C,0x03,0x27,0x41,0x91,0x3A,0x21
};
U8 _entropy2[32] = {
	0x92,0xBA,0xA7,0x65,0x8C,0x23,0xA7,0xEE,0x8E,0x80,0xA8,0xEE,0xCF,0x3E,0x2B,0x68,0x91,0xA5,0x2D,0xFC,0x49,0x68,0x65,0x15,0x00,0x7A,0xC7,0x63,0xF9,0x24,0x4C,0x8C
};


// 초기화용 논스
static 
	U8 _nonce[16] = {
		0xBE,0x1F,0xC1,0x3D,0x92,0x66,0xE5,0x28,0x0C,0x87,0x11,0x2E,0x95,0x59,0x95,0xF3
	};

// 초기화용 개별화 문자열
static 
	U8 _personal[32] = {
		0xA1,0xF6,0xBE,0xBD,0xAF,0x3E,0xCD,0x15,0x51,0x98,0x41,0x75,0x3B,0xF5,0x14,0x7D,0xE0,0x10,0xE9,0xD6,0x93,0xFD,0x4C,0x68,0xEC,0x05,0x3A,0xCD,0x6E,0xB1,0xE4,0x05
};

// 초기화 함수에서 출력된 V
static 
	U8 _V1[55] = {
		0x86,0x63,0x41,0x04,0x3F,0x9F,0x96,0xAF,0x50,0xA9,0x8C,0x3C,0xB6,0xB9,0xBD,0x21,0x36,0x85,0xA3,0xD5,0x42,0xD4,0x2E,0x6E,0x89,0xC4,0xC6,0xED,0x1A,0xEA,0x10,0x0E,0x87,0x3E,0x92,0x66,0x7F,0x7F,0xFF,0x4A,0xD7,0xD0,0x9C,0xA5,0x2B,0xA4,0xD3,0x1A,0x27,0x93,0xD0,0xC2,0xF7,0x86,0x14
	};

// 외부갱신 함수에서 출력된 V
static 
	U8 _V2[55] = {
		0x06,0xF8,0xBA,0xE2,0xE7,0x83,0x15,0xEE,0x31,0xD5,0x55,0xFF,0xF8,0x09,0x5D,0x3E,0xF9,0xE2,0x44,0xC7,0x10,0x5E,0x36,0xC3,0xBA,0x4B,0xA1,0x8F,0x5A,0xF1,0xE6,0x52,0x04,0x7E,0x83,0x0C,0xBE,0xCF,0x55,0xF4,0x44,0x17,0xCD,0x02,0xAC,0xB6,0x2F,0x83,0x19,0xFD,0xBB,0x4B,0xBB,0x72,0xC3
	};

// 초기화 함수에서 출력된 C
static 
	U8 _C1[55] = {
		0xB6,0x27,0xEC,0x63,0x29,0x8B,0x14,0x58,0x63,0x33,0xA3,0x0E,0x8F,0xCE,0x25,0x3F,0xCA,0x97,0xDF,0x30,0x78,0x30,0xDE,0x41,0xF3,0xCC,0x48,0xC4,0x1A,0xD1,0xE1,0x69,0xE6,0x8B,0xAE,0x25,0x31,0x40,0xB1,0xA2,0xC8,0xCD,0x4A,0xF8,0xC6,0xB6,0x44,0xCD,0xBB,0xD9,0x9C,0x6B,0xAD,0xF0,0xCD
	};

// 외부갱신 함수에서 출력된 C
static
	U8 _C2[55] = {
		0x2F,0x69,0x93,0x62,0x53,0x9E,0xD8,0xB5,0x8A,0x39,0xA8,0x74,0xA6,0xE1,0x01,0xEE,0x5D,0xC7,0xA6,0x04,0x54,0x75,0x08,0x78,0x33,0xC8,0xC0,0x6A,0x73,0x03,0x33,0xAC,0xE4,0x8F,0x90,0x2C,0x7A,0x3F,0x31,0xEF,0x07,0xA2,0xCC,0x66,0xD6,0x6D,0xB2,0x2F,0xB9,0x52,0x56,0x9F,0xE4,0x26,0x94
	};

// 추가입력 : 출력생성 함수
static
	U8 _AddInput1[32] = {
		0x66,0x25,0xB0,0x6B,0x16,0xAF,0x81,0xE7,0x13,0xA0,0x38,0x66,0xEC,0x5B,0x7B,0x87,0x0C,0xAB,0xB5,0x97,0xE2,0x5A,0x5D,0xC0,0x3F,0xFF,0x7C,0x7D,0xFF,0x17,0x69,0x51
	};

// 추가입력 : 외부갱신 함수
static 
	U8 _AddInput2[32] = {
		0xEB,0x57,0xD7,0xB9,0xDE,0x41,0x12,0x5F,0x27,0xF6,0x86,0x90,0x2F,0x4B,0x81,0xF0,0x5C,0x1E,0x3A,0x6D,0x34,0xEB,0x11,0x71,0xC6,0x9A,0x18,0x5C,0x45,0x9B,0xD3,0x31
	};

		

// 출력값
static 
	U8 _RandOut1[64] = {
		0xDB,0xEF,0x6E,0xCD,0xEF,0xE7,0x41,0xB5,0xEF,0x1F,0x34,0xBA,0x68,0x38,0x4F,0x6D,0x5B,0xBD,0x7D,0xA7,0x77,0x42,0x9D,0x96,0xC7,0x46,0x93,0xA8,0x51,0x3E,0xB4,0xBC,0xBC,0xC4,0x61,0xB0,0xC7,0x55,0xB9,0x94,0x93,0x62,0x3C,0xCD,0xD3,0x1E,0x3D,0xE1,0x22,0x81,0xF5,0x62,0x6B,0xA8,0x3A,0xC6,0x45,0x94,0xF5,0x13,0x26,0xC0,0x06,0x8E
	};

static
int
SC_DRBG_SelfTest()
{
	SC_HashDRBG_CONTEXT	ctx;
	U8 buf[1024] = {0x00,};
	int len = 0, retCode;

	//
	// 1. 초기화 함수 시험
	retCode = SC_HashDRBG_Init(&ctx, _personal, sizeof(_personal), _nonce, sizeof(_nonce));
	if (retCode != 0) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}

	// 출력값 비교 : V, C
	if (memcmp(_V1, ctx.V, ctx.vLen)) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}

	if (memcmp(_C1, ctx.C, ctx.cLen)) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}

	//
	// 2. 출력생성 함수 시험
	len = 64;
	retCode = SC_HashDRBG_Generate(&ctx, buf, len, _AddInput1, sizeof(_AddInput1), 0); 
	if (retCode != 0) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}
	
	// 출력값 비교 : 첫번째출력
	if (memcmp(_RandOut1, buf, len)) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}
	
	//
	// 3. 외부갱신 함수 시험
	retCode = SC_HashDRBG_Reseed(&ctx, _AddInput2, sizeof(_AddInput2)); 
	if (retCode != 0) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}
	
	// 출력값 비교 : V, C
	if (memcmp(_V2, ctx.V, ctx.vLen)) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}
	
	if (memcmp(_C2, ctx.C, ctx.cLen)) {
		retCode = SCC_SELFTEST_ERROR_ALGORITHM_DRBG_KAT;
		goto end;
	}
	retCode = 0;

end:
	// 파라미터 제로화
	SC_Memzero(&ctx, 0x00, sizeof(ctx));
	return retCode;
}


#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/types.h>

int _mix(unsigned char *output, unsigned char *a, unsigned char *b, int length)
{
	int i=0;

	for(i=0; i<length; i++) {
		if((i/8) % 2 == 1) {
			output[i] = a[i];
		}else {
			output[i] = b[i];
		}
	}

	return length;
}

extern HANDLE	g_crypto_hmodule;

static U8 INTE_KCDSA_P[] = {0x83,0xE5,0x24,0xA3,0x82,0x57,0x2B,0xD9, 0x0F,0x97,0x93,0x1A,0xD9,0x78,0x8D,0xA4,
							0x21,0x0F,0xC3,0x2C,0x65,0x4B,0xBF,0x9B, 0xEF,0x84,0x9A,0xC6,0x15,0x8E,0xA5,0xD5,
							0x69,0xE6,0xEF,0xB9,0x6F,0x4B,0xD6,0xA4, 0x11,0xDF,0xB8,0x6F,0xF6,0xB3,0x2E,0xD7,
							0x33,0x8B,0x42,0x7B,0xBC,0x7A,0xD7,0xE2, 0xFB,0x23,0x42,0xB2,0xCB,0x96,0xBB,0xA5,
							0xB4,0xB3,0x80,0x80,0xD1,0x2D,0x57,0x62, 0x87,0x66,0x4A,0x88,0x28,0xB8,0x31,0x8D,
							0xEA,0xC5,0xC5,0xDE,0x83,0x7B,0x8B,0x91, 0x88,0x85,0xF0,0xC5,0x2A,0xBC,0x29,0xCD,
							0xD5,0xA7,0xE5,0xAB,0xDF,0xEB,0x81,0x57, 0xE9,0xD9,0x7D,0x81,0x2F,0x2B,0xAA,0x98,
							0x77,0x51,0x19,0xC1,0xA9,0x9C,0xE1,0xD7, 0x6C,0x11,0xA5,0x9F,0x53,0xE8,0x23,0xE8,
							0x33,0x3B,0x7D,0xFB,0x2F,0x13,0x74,0x43, 0xD7,0xB1,0x72,0x69,0x77,0xF7,0xB0,0xE7,
							0x81,0x9B,0x92,0x1F,0xC8,0x57,0x52,0x65, 0xE3,0xDD,0xBF,0x86,0x99,0x8E,0x51,0x4D,
							0x4C,0xA3,0x9F,0x51,0x70,0xC8,0x80,0xB6, 0x50,0x27,0xC4,0x77,0x3F,0xF6,0xB5,0x8C,
							0xDF,0xC5,0x0A,0x0B,0xE8,0x7F,0x1C,0x73, 0x3C,0x8A,0xB2,0x2C,0x60,0xB2,0x38,0x02,
							0xF2,0x69,0x9B,0x72,0x2C,0xFC,0x16,0xBC, 0x9A,0x15,0x15,0x10,0x14,0xF2,0x32,0xDE,
							0x08,0x06,0xC5,0xB6,0x24,0xF3,0x9B,0xC4, 0xB2,0xF1,0x3D,0x1F,0x56,0xE3,0xA0,0x6B,
							0x69,0x73,0xF1,0x3F,0x49,0x77,0x25,0x4E, 0xD7,0xA5,0xE2,0x5E,0x7E,0xF0,0x66,0xCA,
							0x91,0x79,0xF9,0x77,0x62,0xBA,0x48,0x89, 0x1F,0xD3,0x59,0x88,0x3D,0x53,0xB7,0x9F };

static U8 INTE_KCDSA_Q[] = {0x92,0x94,0x51,0x58,0xC2,0x90,0xF4,0x00, 0x98,0x40,0x0E,0x10,0x34,0x75,0xA5,0x85,
							0x8C,0x59,0xFC,0x08,0xF4,0x42,0xD0,0xE1, 0xCA,0xB0,0x47,0x2F,0xBE,0xB8,0x45,0x24};

static U8 INTE_KCDSA_G[] = { 0x3C,0x06,0xB4,0xC6,0x6B,0xE0,0xE5,0xBA, 0xA3,0xCF,0x7B,0xED,0x2C,0x4A,0x4F,0x8F,
							0xCD,0xCB,0x1E,0x06,0xF2,0x49,0xF6,0xB1, 0x8E,0x00,0x0D,0x95,0x39,0xF2,0xF0,0x40,
							0x8E,0x6E,0x36,0x35,0xB1,0x3C,0x2A,0x8D, 0x2D,0x34,0xF2,0x78,0xFF,0xCA,0x8B,0x59,
							0x34,0x18,0xD6,0x7F,0xE3,0xF7,0xBD,0xCB, 0x01,0x19,0x34,0xF6,0x7D,0x49,0xEF,0x9A,
							0x40,0x18,0x1B,0x96,0x73,0x2D,0xB6,0x76, 0xE6,0x05,0xD9,0x6C,0xC7,0x5B,0x70,0x60,
							0xA9,0xF8,0xE8,0xD6,0xC1,0x47,0x86,0x55, 0x37,0x51,0xB4,0x1B,0xB5,0xDE,0x16,0x01,
							0xF5,0x50,0x48,0x91,0xEB,0xF2,0x15,0x3D, 0x5C,0xB6,0x24,0xB0,0x2A,0xBF,0x37,0x79,
							0x8E,0xF5,0x59,0x44,0xF1,0xCA,0xBE,0x87, 0x70,0x41,0x4F,0xC0,0x1E,0x77,0xB5,0x8B,
							0xA5,0x95,0xA3,0x9B,0xE1,0x12,0xA6,0xBC, 0x1F,0xB2,0x8A,0xA1,0xD4,0xB6,0x71,0x92,
							0x53,0x0F,0x00,0xDF,0x81,0x83,0xB4,0xBF, 0xEF,0x81,0x33,0x48,0xD8,0xC4,0x03,0x79,
							0xED,0x4C,0x01,0xE8,0x9E,0x58,0x6F,0x45, 0x90,0x87,0xAD,0xA9,0xBF,0x03,0x22,0x3F,
							0xAF,0xDA,0xFF,0xF2,0x3D,0x02,0xE9,0x2D, 0xEC,0xDF,0x1C,0x0E,0xC6,0x2A,0x5F,0x5C,
							0xEF,0x53,0x25,0x4C,0x6B,0xA0,0x22,0x2F, 0xFF,0x26,0xE4,0x8A,0xB5,0xA6,0x98,0x1C,
							0x6C,0x4D,0x50,0xD4,0x3D,0xA6,0x86,0xCB, 0xCE,0x6D,0x0E,0xFC,0xB8,0x5A,0x01,0x58,
							0x33,0xE4,0x36,0xFF,0x85,0x8B,0xEC,0x57, 0xF5,0x8F,0xAC,0xED,0x12,0x25,0x6F,0x48,
							0x9C,0x17,0xEE,0xD5,0x39,0x7A,0x73,0xD5, 0x99,0xE2,0xA0,0xB0,0xCC,0x31,0x11,0x00};

static U8 INTE_KCDSA_Y[] = { 0x35,0x87,0xF6,0x06,0x9F,0x8F,0x8E,0xAF, 0xE2,0x3B,0x87,0x79,0x35,0x47,0x2E,0xD2,
								0xAC,0x0C,0xAA,0x26,0x71,0x36,0xDF,0xFA, 0x88,0x26,0x44,0xDF,0xC4,0x68,0x7A,0xE2,
								0xA6,0x8E,0x12,0xB2,0x97,0x69,0x12,0x59, 0xD3,0xB1,0xB8,0xF4,0xAF,0x94,0x65,0x29,
								0x7E,0xF5,0x5D,0xDB,0x77,0xC1,0x80,0x1E, 0x4E,0x28,0xDC,0x16,0x64,0xFF,0x8E,0xDF,
								0xB0,0x2D,0xA6,0xFC,0xD3,0x2A,0xA0,0xF4, 0x21,0x3D,0x23,0xF5,0x82,0x7E,0x13,0xF0,
								0x9C,0x92,0x8F,0x2A,0x65,0xD2,0x39,0x30, 0x04,0x12,0x78,0x37,0x15,0x4D,0xDC,0x82,
								0x63,0x99,0xCA,0xFA,0x82,0xDF,0xC2,0x02, 0x1D,0x70,0x7C,0x5D,0xEE,0x05,0xF4,0x1E,
								0xD1,0x07,0x92,0x32,0xA1,0xE4,0xCA,0xA4, 0x79,0x7F,0x17,0x7A,0x3E,0xC8,0xE4,0x42,
								0x7F,0xC8,0x90,0x38,0x99,0x18,0x7F,0x09, 0x36,0xE2,0xCC,0xBE,0xD9,0x3A,0xDF,0x4E,
								0xCD,0xA8,0x7A,0x77,0x69,0x3B,0x1A,0xC9, 0xA2,0x73,0x72,0x23,0xC8,0x7C,0x57,0x26,
								0x5C,0x6D,0x40,0x88,0x00,0x54,0xB5,0x51, 0xD4,0xD8,0xFE,0x22,0x17,0x96,0xA5,0x9E,
								0x00,0x24,0x77,0x00,0x0C,0x78,0x75,0x88, 0x8C,0xDF,0x94,0x8A,0x01,0xBA,0x77,0x50,
								0xA1,0x8C,0x5B,0x4B,0xBF,0x40,0xA0,0x0F, 0x64,0x29,0x6E,0x01,0xEA,0x33,0xE1,0xDB,
								0x05,0xB6,0xDE,0x4C,0x48,0xE0,0x09,0x72, 0x8D,0x24,0x37,0xDE,0xC3,0x3A,0xB7,0xAC,
								0x02,0x40,0x3A,0x09,0xF9,0x47,0x67,0x09, 0xB3,0xA8,0xCB,0x08,0xCC,0xB2,0x41,0x48,
								0x7C,0xED,0xBF,0x15,0x35,0xAC,0xD5,0x10, 0xBD,0x05,0xE0,0xA4,0xD5,0x2B,0x08,0x2B};

static
int
SC_CMVP_IntegrityTest(void)
{
	U8 *buffer = NULL;
	U8 modulename[MAX_PATH] = {0x00,};
	U8 filetail[68] = {0x00,};
	struct stat	st;
	int fd = -1, len;
	
	int retCode = 0;
	
	U8 signature[4096] = {0x00,};
	U32 signatureLength = 0;

	SC_PKEY_PublicKey  pubKey;
	SC_PKEY_Parameters params;
	SC_PKEY_SignParam  signParam;
	SC_BIGINT y;

	int i = 0;

	U8 a[256] = {0x00,};
	U8 b[256] = {0x00,};
	U8 c[256] = {0x00,};

	int aLength = 0;
	int bLength = 0;
	int cLength = 0;

	GetModuleFileNameA(g_crypto_hmodule, modulename, sizeof(modulename));

	// open file with read mode
	fd = _open(modulename, (_O_RDONLY | _O_BINARY), 0);
	if (fd < 0) { 
		retCode = -1; goto end; 
	}

	if (stat(modulename, &st) < 0) {
		retCode = -1; goto end;
	}

	// check whether file has hmac code or not
	if (st.st_size <= (4+64)) { retCode = -1; goto end; }

	if (_lseek(fd, -(4+64), SEEK_END) < 0) { 
		retCode = -1; goto end;
	}

	len = _read(fd, filetail, (4+64));
	if (len != 68) {
		retCode = -1; goto end;
	}

	// calc length
	signatureLength = filetail[0] * 0x1000000;
	signatureLength += filetail[1] * 0x10000;
	signatureLength += filetail[2] * 0x100;
	signatureLength += filetail[3];
	if(signatureLength != 64) {
		retCode = -1; goto end;
	}

	// read module
	if (_lseek(fd, 0, SEEK_SET) < 0) {
		retCode = -1; goto end;
	}

	if ((buffer = sc_calloc(st.st_size, sizeof(char))) == NULL) {
		retCode = -1; goto end;
	}

	len = _read(fd, buffer, st.st_size);
	if (len != st.st_size) { 
		retCode = -1; goto end; 
	}
	params.pkeyID = pubKey.pkeyID = SC_PKEY_ID_KCDSA;

	retCode = SC_KCDSA_CreateKeyObject((SC_KCDSA_Parameters **)&params.params);
	if(retCode < 0) goto end;

	SC_Bigint_New(&y);
	pubKey.pubKey = &y;
		
	getPublicKey1(b, &bLength);
	cLength = _mix(c, b, INTE_KCDSA_P, sizeof(INTE_KCDSA_P));
	aLength = SC_Codec(a, c, cLength);
	SC_BIGINT_CHK( SC_Bigint_Read_Binary( &((SC_KCDSA_Parameters *)params.params)->KCDSA_p, a, aLength ) );

	getPublicKey2(b, &bLength);
	cLength = _mix(c, b, INTE_KCDSA_Q, sizeof(INTE_KCDSA_Q));
	aLength = SC_Codec(a, c, cLength);
	SC_BIGINT_CHK( SC_Bigint_Read_Binary( &((SC_KCDSA_Parameters *)params.params)->KCDSA_q, a, aLength ) );

	getPublicKey3(b, &bLength);
	cLength = _mix(c, b, INTE_KCDSA_G, sizeof(INTE_KCDSA_G));
	aLength = SC_Codec(a, c, cLength);
	SC_BIGINT_CHK( SC_Bigint_Read_Binary( &((SC_KCDSA_Parameters *)params.params)->KCDSA_g, a, aLength ) );

	getPublicKey4(b, &bLength);
	cLength = _mix(c, b, INTE_KCDSA_Y, sizeof(INTE_KCDSA_Y));
	aLength = SC_Codec(a, c, cLength);
	SC_BIGINT_CHK( SC_Bigint_Read_Binary( &y, a, aLength ) );

	signParam.kcdsa.pkPubKey = &pubKey;

	retCode = SC_PKEY_Verify(filetail + 4, signatureLength, SC_PKEY_MSGID_MESSAGE, buffer, len-68, SC_PKEY_SIGNID_KCDSA_SHA256, &pubKey, &params, &signParam);
	if(retCode < 0) goto end;

end:
	if(retCode != 0) {
		retCode = SCC_SELFTEST_ERROR_INTEGRITY;
	}

	if (buffer != NULL) sc_free(buffer);

	SC_Memzero(a, 0x00, sizeof(a));
	SC_Memzero(b, 0x00, sizeof(b));
	SC_Memzero(c, 0x00, sizeof(c));
	
	_close(fd);

	return retCode;

}

/**
 *
 *
 *
 */
static
int
SC_CMVP_AlgorithmTest(void)
{
	int	retCode = 0;

	// cryptographic algorithm test
	
	retCode  = SC_ARIA_SelfTest();
	if(retCode < 0) goto end;

	retCode = SC_Hash256_SelfTest();
	if(retCode < 0) goto end;
	
	retCode = SC_Hash512_SelfTest();
	if(retCode < 0) goto end;
	
	retCode = SC_HMAC256_SelfTest();
	if(retCode < 0) goto end;
	
	retCode = SC_HMAC512_SelfTest();
	if(retCode < 0) goto end;
 	
	retCode = SC_RSA_SelfTest();
	if(retCode < 0) goto end;
	
	retCode = SC_KCDSA_SelfTest();
	if(retCode < 0) goto end;

	// HASH_DRBG
	retCode = SC_DRBG_SelfTest();
	if(retCode < 0) goto end;

end:
	return retCode;
}



static
int
SC_RAND_SelfTest()
{
	U8		random[33];
	U32		randomLength = 32;
	int	retCode;

	retCode = SC_CMVP_RAND_Init();
	if (retCode != 0) goto end;
	
	retCode = SC_CMVP_RAND_GetRandom(random, randomLength);
	if (retCode != 0) goto end;

	retCode = 0;

end:
	return retCode;
}


/**
 *
 *
 *
 */
int
SC_CMVP_SelfTest(void)
{
	int retCode = 0, len = 0;
	SC_ENTROPY_CTX entropy_ctx_1;
	SC_ENTROPY_CTX entropy_ctx_2;

	// 자가시험 상태 진입
	retCode = SC_CMVP_MoveStatus(SCC_STATUS_SELFTEST);
	if (retCode != 0) goto end;

	retCode = SC_CMVP_AlgorithmTest();
	if (retCode != 0) goto end;

	retCode = SC_CMVP_IntegrityTest();
	if (retCode != 0) goto end;
	// 난수발생기 엔트로피 시험
	retCode = SC_Entropy_Accumulate(&entropy_ctx_1);
	if (retCode != 0) goto end;

	retCode = SC_Entropy_Accumulate(&entropy_ctx_2);
	if (retCode != 0) goto end;

	// 두 개의 엔트로피가 서로 같으면 실패
	if (entropy_ctx_1.dataLength != entropy_ctx_2.dataLength) {
		retCode = SCC_SELFTEST_ERROR_ENTROPY_COMPARE;
		goto end;
	}
	len = entropy_ctx_1.dataLength;
	//TEST: entropy source Length check
	//printf("entropy source length : %d\n", len);
	if(memcmp(entropy_ctx_1.data, entropy_ctx_2.data, len) == 0) {
		retCode = SCC_SELFTEST_ERROR_ENTROPY_COMPARE;
		goto end;
	}

end:
	// 엔트로피 제로화
	SC_Memzero(&entropy_ctx_1, 0x00, sizeof(SC_ENTROPY_CTX));
	SC_Memzero(&entropy_ctx_2, 0x00, sizeof(SC_ENTROPY_CTX));

	return retCode;
}